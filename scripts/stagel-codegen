#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
#set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes parsed StageL tokens from standard input, and prints out equivalent code in the language of the first argument (bash/js).

targetLang="$1"

# Read token data into tokens array

tokens=()

while IFS=$'\n' read -r line; do
    tokens+=("$line")
done

tokenCount="${#tokens[@]}"

#declare -p tokens >&2
echo "Document contains $((tokenCount / 3)) tokens." >&2
for (( i=0; i<tokenCount; i++ )); do
    ! (( (i+1) % 3 )) && echo "Token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
done

# We now know what each token is, so let's do the code generation.

if [[ "$targetLang" == "parsed" ]]; then
    # Just dump the parse results and exit; for correct input this should produce identical output.
    for (( i=0; i<tokenCount; i++ )); do
        echo "${tokens[$i]}"
    done
    true
    exit
fi

# Set up the variables we'll need for going through the tokens and generating the code

codegenIndent=0
codegenLastKnownArglistCount=0
codegenRoutineType=""
codegenRoutineName=""
codegenArgList=()
codegenNewLine="true"
codegenNewlineLookingForSpaces="true" # True while finding indentation spaces at the beginning of a line.
codegenTestIndentDeferred="false" # True while waiting to come to the code-block portion of a "test"-style construct (e.g. "if") that has a multiline test part
codegenArrayLiteral=""
stateStack=("root" "code")
blockStack=("root" "")
testParameterFound="false" # This is set to "false" usually. When a token that uses a "test" syntax (e.g. if, or any other thing that first takes a value and also starts a code block) is encountered, it stays false until something representing a value is found, at which point it is set to "true". It's returned to "false" once the test's associated code block is located.
codegenStatus="Nothing done yet"
tokenLookahead=""
filename=""

# Define a function for each type of output needed for code generation

codegenOnNewLine() {
    [[ "$codegenNewLine" == "true" ]]
}

codegenOutput() {
    echo "(codegenOutput: ${@})" >&2
    print "${@}"
    if [[ "$*" == *$'\n' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    elif [[ "$codegenNewlineLookingForSpaces" == "true" ]] && [[ "$*" == *$'    ' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    else
        codegenNewLine="false"
    fi
}

codegenDebug() {
    echo "$codegenStatus (Debug info: Codegen: $1, routine $codegenRoutineType:$codegenRoutineName / Args: $* / States: ${stateStack[*]} / Blocks: ${blockStack[*]} / Arglist: ${codegenArgList[*]} / ($codegenNewlineLookingForSpaces/$codegenTestIndentDeferred/$testParameterFound).)" >&2
    #print_r "${blockStack[@]}" >&2
}

codegenType() {
    codegenDebug "Type" "${@}" >&2
    # First arg: type; second arg: "true" for uppercase first letter
    local result=""
    case "$targetLang" in
    "js")
        [[ "$1" == "literal-b" ]] && result='bool'
        [[ "$1" == "literal-n" ]] && result='int'
        [[ "$1" == "literal-s" ]] && result='str'
        [[ "$1" == "ident-b" ]] && result='bool'
        [[ "$1" == "ident-g" ]] && result='generic'
        [[ "$1" == "ident-n" ]] && result='int'
        [[ "$1" == "ident-s" ]] && result='str'
        [[ "$1" == "ident-ab" ]] && result='boolArray'
        [[ "$1" == "ident-an" ]] && result='intArray'
        [[ "$1" == "ident-as" ]] && result='strArray'
        [[ "$1" == "ident-ga" ]] && result='genericArray'
        [[ "$1" == "ident-gi" ]] && result='genericItem'
        [[ "$1" == "ident-r-b" ]] && result='bool'
        [[ "$1" == "ident-r-n" ]] && result='int'
        [[ "$1" == "ident-r-s" ]] && result='str'
        [[ "$1" == "ident-r-v" ]] && result='void'
        [[ "$1" == "ident-r-ab" ]] && result='boolArray'
        [[ "$1" == "ident-r-an" ]] && result='intArray'
        [[ "$1" == "ident-r-as" ]] && result='strArray'
        #[[ -z "$result" ]] && result="$1"
        [[ -z "$result" ]] && die "$1 is not a recognized type!"
        if [[ "$2" == "true" ]]; then
            codegenOutput "${result^}"
        else
            codegenOutput "$result"
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenLiteral() {
    codegenDebug "Literal" "${@}" >&2
    # First arg: type; second arg: value
    case "$targetLang" in
    "js")
        case "$1" in
        "literal-s")
            codegenOutput \'"$(asciiDecListToText "$2")"\'
            ;;
        "literal-n"|"literal-b")
            codegenOutput "$2"
            ;;
        "literal-sn"|"literal-an"|"literal-bn")
            codegenOutput "$2"
            ;;
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenReference() {
    codegenDebug "Reference" "${@}" >&2
    # Reference to a variable
    # First arg: type; second arg: name
    case "$targetLang" in
    "js")
        codegenType "$1"
        codegenOutput "${2^}"
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenPrintIndentationSpaces() {
    for (( j=0; j<codegenIndent; j++ )); do
        codegenOnNewLine && codegenOutput '    '
    done
    true
}

codegenStartDocument() {
    codegenDebug "Start document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndDocument() {
    codegenDebug "End document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIndent() {
    codegenDebug "Indent" "${@}" >&2
    codegenOnNewLine && codegenPrintIndentationSpaces
    case "$targetLang" in
    "js")
        codegenOnNewLine || codegenOutput ' '
        codegenOutput '{'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenDedent() {
    codegenDebug "Dedent" "${@}" >&2
    #codegenIndent=$(( codegenIndent - 1 ))
    codegenPrintIndentationSpaces
    #codegenIndent=$(( codegenIndent + 1 ))
    case "$targetLang" in
    "js")
        codegenOutput '}'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    #set +x
}

codegenComment() {
    codegenDebug "Comment" "${@}" >&2
    codegenPrintIndentationSpaces
    case "$targetLang" in
    "js")
        codegenOutput "/*""$1 */"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenArglistHasInvocation() {
    local counter="${#codegenArgList[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if  [[ "${codegenArgList[$counter]}" == ident-r-* ]]; then
            return 0
        fi
        counter=$(( counter - 1 ))
    done
    return 1
}

codegenGetCurrentRoutineType() {
    local counter="${#blockStack[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if ( codegenType "${blockStack[$counter]}" &> /dev/null; ); then
            codegenOutput "${blockStack[$counter]}"
            return 0
        fi
        counter=$(( counter - 1 ))
    done
}

codegenInitializeType() {
    codegenDebug "Initialize type" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput " = "
        case "$1" in
        "bool")
            codegenOutput 'false'
            ;;
        "int")
            codegenOutput '0'
            ;;
        "str")
            codegenOutput "''"
            ;;
        "boolArray")
            codegenOutput "[]"
            ;;
        "intArray")
            codegenOutput "[]"
            ;;
        "strArray")
            codegenOutput "[]"
            ;;
        "genericArray")
            codegenOutput "[]"
            ;;
        *)
            die "Initialize requested for unexpected type of $1."
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenStartArray() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput '[ '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenArrayEntryDelimiter() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ', '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndArray() {
    codegenDebug "End array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ' ]'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenCommandInvocationStart() {
    codegenDebug "Command invocation start" "${@}" >&2
    case "$codegenRoutineName" in
    new)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when declaring a variable. Please use set to assign it after declaration."
        fi
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            codegenOutput "let "
            if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                #set -x
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                if [[ "$tokenLookahead" =~ ^(ident-|literal-) ]]; then
                    codegenOutput ' = '
                    tokenLookahead=""
                else
                    local type
                    type="$(codegenType "${codegenArgList[-2]}")"
                    [[ "$type" =~ ^(generic|genericItem)$ ]] || codegenInitializeType "$type"
                fi
                #set +x
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    return)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when returning. Please assign the value to a variable and return that."
        fi
        codegenOutput $'\n'
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            local returnType
            returnType="$(codegenGetCurrentRoutineType)" || true
            [[ -z "$returnType" ]] && die "Tried to return, but was not inside a routine!"
            codegenType "$returnType"
            codegenOutput "Return = "
            if [[ "${codegenArgList[-2]}" == ident-* ]]; then
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            fi
            codegenOutput "; await assertIs"
            codegenType "$returnType" true
            codegenOutput "("
            codegenType "$returnType"
            codegenOutput "Return); "
            codegenRoutineDefinitionPreEnd
            codegenOutput "return "
            codegenType "$returnType"
            codegenOutput "Return;"$'\n'
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    if|while)
        codegenPrintIndentationSpaces
        codegenOutput "$codegenRoutineName ("
        ;;
    else|debugger)
        # debugger isn't a StageL command, but I want to be able to use it in firefox js
        codegenPrintIndentationSpaces
        codegenOutput "$codegenRoutineName"
        ;;
    elif)
        codegenPrintIndentationSpaces
        codegenOutput "else if ("
        ;;
    until)
        codegenPrintIndentationSpaces
        codegenOutput "while !("
        ;;
    and|not|eq|gt|lt|add|sub|mul|div|mod|cat|die|error|warn|log|debug)
        codegenPrintIndentationSpaces
        # These commands are implemented with impl* calls
        # The only purpose of using "impl" now is to prevent collisions with things that are likely to be reserved words in target languages; so, e.g. "implFIXMEUnimplemented" is unnecessary since it can just be "FIXMEUnimplemented" and be unlikely to collide.
        case "$targetLang" in
        "js")
            codegenOutput "await impl${codegenRoutineName^}("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    set)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput ";"$'\n'
            else
                # It's getting set to a command's return value
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput ' = '
                unset 'codegenArgList[-1]'
                unset 'codegenArgList[-1]'
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            codegenOutput "await $codegenRoutineName("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationArgSeparator() {
    codegenDebug "Command invocation argument separator" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ", "
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenCommandInvocationArglist() {
    codegenDebug "Command invocation argument list" "${@}" >&2
    case "$targetLang" in
    "js")
    #set -x
        argumentCount="${#codegenArgList[@]}"
        codegenLastKnownArglistCount="$argumentCount"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                if [[ "${codegenArgList[$k - 1]}" == literal-* ]]; then
                    codegenLiteral "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                else
                    codegenReference "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                fi
                if [[ "$k" != $((argumentCount - 1)) ]]; then
                    codegenCommandInvocationArgSeparator
                fi
            fi
        done
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationEnd() {
    codegenDebug "Command invocation end" "${@}" >&2
    case "$codegenRoutineName" in
    return|new)
        # This shouldn't happen, because it's all handled in codegenCommandInvocationStart
        die "Internal error (this is a bug): codegenCommandInvocationEnd called for return"
        ;;
    add|eq|mod)
        # These commands are implemented with impl* calls
        case "$targetLang" in
        "js")
            codegenOutput ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        #codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            { [[ "${blockStack[-2]}" == "command" ]] && [[ "${blockStack[-1]}" =~ ^(new|return|set|else|debugger)$ ]]; } || codegenOutput ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    if ! contains "test" "${stateStack[@]}"; then
        [[ "${stateStack[-2]}" != "arglist" ]] && [[ "${blockStack[-1]}" != "else" ]] && codegenOutput ';'$'\n'
    fi
    blockStackRemoveLast
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionStart() {
    codegenDebug "Routine definition start" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput "async function $codegenRoutineName("
        argumentCount="${#codegenArgList[@]}"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenType "${codegenArgList[$k - 1]}"
                if [[ "$k" == $((argumentCount - 1)) ]]; then
                    codegenOutput "${codegenArgList[$k]^}"
                else
                    codegenOutput "${codegenArgList[$k]^}, "
                fi
            fi
        done
        codegenOutput ") {"$'\n'
        codegenIndent=$(( codegenIndent + 1 ))
        codegenPrintIndentationSpaces
        codegenIndent=$(( codegenIndent - 1 ))
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenOutput "await internalDebugCollect('"
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput " ${codegenArgList[$k]^} = ' + "
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput "${codegenArgList[$k]^} + '; '); "
            fi
        done
        codegenOutput "await internalDebugStackEnter('$codegenRoutineName:$filename');"
        if [[ "$argumentCount" != 0 ]] || [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                [[ "$k" != 1 ]] && codegenOutput ' '
                codegenOutput "await assertIs"
                codegenType "${codegenArgList[$k - 1]}" "true"
                codegenOutput "("
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput "${codegenArgList[$k]^});"
            fi
        done
        if [[ "$argumentCount" != 0 ]] && [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        if [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput "let "
            codegenType "$codegenRoutineType"
            codegenOutput "Return;"
        fi
        codegenOutput $'\n\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionPreEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    "js")
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenOutput $'\n'
            codegenIndent=$(( codegenIndent + 1 ))
            codegenPrintIndentationSpaces
            codegenIndent=$(( codegenIndent - 1 ))
        fi
        codegenOutput "await internalDebugStackExit();"
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenOutput $'\n'
        else
            codegenOutput " "
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenRoutineDefinitionEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    "js")
        # codegenOutput "}"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIsTestCommand() {
    case "$1" in
    for|if|elif|until|while)
        true
        ;;
    *)
        false
        ;;
    esac
}

blockStackRemoveLast() {
    print_r "${blockStack[@]}" >&2
    if [[ "${blockStack[-1]}" == "" ]] && [[ "${blockStack[-2]}" == "plain-block" ]] && [[ "${blockStack[-4]}" == "test" ]]; then
        unset 'blockStack[-1]'
        unset 'blockStack[-1]'
    fi
    unset 'blockStack[-1]'
    [[ "${blockStack[-1]}" == "root" ]] && die "Internal error: Trying to remove root block!"
    unset 'blockStack[-1]'
}

codegenArrayAppend() {
    codegenArrayLiteral="$codegenArrayLiteral$1"
}

codegenGetArrayLiteral() {
    print "$codegenArrayLiteral"
    codegenArrayLiteral=""
}

#set -x
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        codegenIndent="${tokens[$i - 2]##*:}"

        #declare -p tokens >&2
        #declare -p stateStack >&2
        echo >&2
        codegenStatus="State: ${stateStack[-1]}:$codegenIndent, token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)"
        codegenDebug

        if [[ "${tokens[$i - 1]}" == "filename" ]]; then
            filename="${tokens[$i]}"
        elif [[ "${tokens[$i - 1]}" == "comment" ]] && [[ "${stateStack[-1]}" != "arglist" ]] && [[ "${stateStack[-1]}" != literal-a* ]]; then
            echo "(Inserting a comment)" >&2
            codegenComment "$(asciiDecListToText "${tokens[$i]}")"
        elif [[ "${tokens[$i - 1]}" == "literal-ab-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "b")"
            stateStack+=("literal-ab")
        elif [[ "${tokens[$i - 1]}" == "literal-an-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "n")"
            stateStack+=("literal-an")
        elif [[ "${tokens[$i - 1]}" == "literal-as-start" ]]; then
            codegenArrayAppend "$(codegenStartArray "s")"
            stateStack+=("literal-as")
        else
            case "${stateStack[-1]}" in
            literal-ab)
                case "${tokens[$i - 1]}" in
                literal-ab-end)
                    codegenArrayAppend "$(codegenEndArray "b")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-b)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-b)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend "$(codegenOutput $'\n')"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of booleans."
                    ;;
                esac
                ;;
            literal-an)
                case "${tokens[$i - 1]}" in
                literal-an-end)
                    codegenArrayAppend "$(codegenEndArray "n")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-n)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-n)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend "$(codegenOutput $'\n')"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of numbers."
                    ;;
                esac
                ;;
            literal-as)
                case "${tokens[$i - 1]}" in
                literal-as-end)
                    codegenArrayAppend "$(codegenEndArray "s")"
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                literal-s)
                    codegenArrayAppend "$(codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                ident-s)
                    codegenArrayAppend "$(codegenReference "${tokens[$i - 1]}" "${tokens[$i]}")"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    ;;
                newline)
                    codegenArrayAppend "$(codegenArrayEntryDelimiter)"
                    codegenArrayAppend "$(codegenOutput $'\n')"
                    codegenArrayAppend "$(codegenPrintIndentationSpaces)"
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of strings."
                    ;;
                esac
                ;;
            code)
                echo "Working on code" >&2
                case "${tokens[$i - 1]}" in
                start-document)
                    codegenStartDocument
                    ;;
                end-document)
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                indent)
                    codegenIndent
                    stateStack+=("code")
                    blockStack+=("plain-block" "")
                    ;;
                dedent)
                    [[ "${blockStack[-2]}" == "ident-r-v" ]] && codegenRoutineDefinitionPreEnd # This gets generated before the return for non-void routines
                    codegenDedent
                    unset 'stateStack[-1]'
                    blockStackRemoveLast
                    ;;
                ident-r-*)
                    codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                    if ! [[ "${tokens[$i - 4]}" =~ ^(start-document|filename)$ ]]; then
                        codegenOutput $'\n'
                    fi
                    codegenRoutineType="${tokens[$i - 1]}"
                    stateStack+=("routine-definition")
                    blockStack+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command)
                    codegenRoutineName="${tokens[$i]}"
                    case "${tokens[$i]}" in
                    if|elif|until|while)
                        stateStack+=("test")
                        blockStack+=("test" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    new|set)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        # We need to slurp up the first token of this arglist, representing the identifier, since it's needed by codegenCommandInvocationStart. Then, codegenCommandInvocationStart gets called.
                        stateStack+=("identifier-command-argument-accumulation")
                        ;;
                    return)
                        stateStack+=("oneshot-command")
                        ;;
                    *)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    esac
                    ;;
                newline)
                    #[[ "${tokens[$i - 4]}" == "newline" ]] && codegenOutput $'\n'
                    ;;
                *)
                    die "A ${tokens[$i - 1]}, ${tokens[$i]}, isn't allowed here, in ${blockStack[-2]} ${blockStack[-1]}."
                    ;;
                esac
                ;;
            oneshot-command)
                case "${tokens[$i - 1]}" in
                literal-a*-end)
                    # Some type of data, array literal.
                    codegenArgList+=("${tokens[$i - 1]}" "$(codegenGetArrayLiteral)")
                    ;;
                literal-*)
                    # Some type of data, literal.
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                *)
                    # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                    codegenCommandInvocationStart
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                esac
                ;;
            identifier-command-argument-accumulation)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                ident-*)
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    unset 'stateStack[-1]'
                    tokenLookahead="${tokens[$i + 2]}" # should hold the next token type
                    codegenCommandInvocationStart
                    ;;
                *)
                    die "A ${blockStack[-2]} ${blockStack[-1]} wants an identifier here, not a ${tokens[$i - 1]}."
                    ;;
                esac
                ;;
            arglist|test)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                literal-a*-end)
                    # Some type of data, array literal.
                    codegenArgList+=("${tokens[$i - 1]}" "$(codegenGetArrayLiteral)")
                    ;;
                literal-*)
                    # Some type of data, literal.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple literals (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command|ident-r-*)
                    if [[ "${tokens[$i]}" =~ ^(return|new|set)$ ]] || { [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] ; }; then
                        # The arglist is ended, so drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                    else
                        if [[ "${stateStack[-1]}" != "test" ]]; then
                            codegenCommandInvocationArglist
                            if ! codegenIsTestCommand "${tokens[$i - 3]}"; then
                                [[ "$codegenLastKnownArglistCount" != 0 ]] && codegenCommandInvocationArgSeparator
                            fi
                        fi
                        codegenRoutineName="${tokens[$i]}"
                        [[ "${tokens[$i - 1]}" == ident-r-* ]] && codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                        codegenCommandInvocationStart
                        if [[ "${stateStack[-1]}" == "test" ]]; then
                            testParameterFound="true"
                        fi
                        stateStack+=("arglist")
                        blockStack+=("arglist-command" "${tokens[$i]}")
                    fi
                    ;;
                ident-*)
                    # Some type of data, reference.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple identifiers (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent)
                    if [[ "$testParameterFound" == "true" ]]; then
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                        i=$((i - 3))
                    fi
                    ;;
                newline)
                    if [[ "${stateStack[-1]}" != "test" ]]; then
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        # (This gets called multiple times for a single test, when there are multiple arglists to close for it.)
                        if [[ "${blockStack[-1]}" != "else" ]]; then
                            codegenCommandInvocationArglist
                        fi
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                    fi
                    # If the test continues onto a new line, make a note that the indentation count will be offset accordingly until the end of the test is found.
                    if [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" != "true" ]]; then
                        codegenOutput $'\n'
                        codegenTestIndentDeferred="indent-deferred"
                    fi
                    ;;
                inline-arglist-end)
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    codegenCommandInvocationArgSeparator
                    unset 'stateStack[-1]' # remove latest "arglist" state
                    ;;
                dedent|end-document|*)
                    # The arglist or test parameter is ended, so do codegen for the command invocation, drop back and continue parsing.
                    # * matches e.g. routine definitions
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    #[[ "${tokens[$i - 1]}" == "dedent" ]] || codegenIndent
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                    stateStack+=("code")
                    ;;
                *)
                    die "What's this token ${tokens[$i - 1]} ${tokens[$i]} doing here? does it need special handling?"
                    ;;
                esac
                ;;
            routine-definition)
                echo "Working on routine definition" >&2
                # Format: token, [ident...], code body
                # So now we look for as many types as there are. When no more types, it enters the code body of the routine. When there's a dedent, it leaves the code body of the routine.
                case "${tokens[$i - 1]}" in
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent|newline)
                    # The routine definition parameter list is ended, so do codegen for the routine declaration (but not the body of it), and continue parsing.
                    codegenRoutineDefinitionStart
                    stateStack[-1]="routine-definition-end"
                    stateStack+=("code")
                    # Avoid putting in an extra code level
                    [[ "${tokens[$i - 1]}" == "newline" ]] && [[ "${tokens[$i + 2]}" == "indent" ]] && i=$((i + 3))
                    ;;
                *)
                    die "Routine definition unexpected token type"
                esac
                ;;
            routine-definition-end)
                echo "Working on routine definition end" >&2
                # Note that this is called AFTER the dedent closing brace is produced. Use codegenRoutineDefinitionPreEnd instead for things that go before the end of the routine def.
                [[ "${tokens[$i - 1]}" == "dedent" ]] && codegenDedent
                unset 'stateStack[-1]'
                codegenRoutineDefinitionEnd
                # And we'll reprocess this token now that we're done with this routine-definition.
                i=$((i - 3))
                # Don't call blockStackRemoveLast here: routine-definition-end state is entered by encountering a dedent while in code mode of the body of the routine, which will pop from the stateStack (thereby uncovering the routine-definition-end state) and take care of calling blockStackRemoveLast.
                ;;
            root)
                case "${tokens[$i - 1]}" in
                end-document)
                    codegenEndDocument
                    ;;
                *)
                    ;;
                esac
                true
                ;;
            *)
                die "Unimplemented code generation state ${stateStack[-1]}"
                ;;
            esac
        fi
    fi
done

{ [[ "${#blockStack[@]}" == "2" ]] && [[ "${blockStack[0]}" == "root" ]] && [[ "${blockStack[1]}" == "" ]]; } || die "Internal error: not all blocks were consumed, or too many blocks were consumed! This is a bug in the StageL transpiler. Remaining block stack: ${blockStack[*]}"

print_r "${stateStack[@]}" >&2
print_r "${blockStack[@]}" >&2
