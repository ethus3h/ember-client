#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
#set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes a StageL file as first argument, and prints out equivalent code in the language of the second argument (bash/js).

input="$1"
targetLang="$2"

tokens=()

# First, break up the input into tokens in the tokens array. This doesn't support streaming, so isn't good for long documents, but should suffice for now. The format should be streamable to other formats; this was just easier to implement for now.

parserState="token"
currentIndentLevel="0"
countingIndentSpaces="true"
indentSpacesCounted="0"
lineNumber="1"
columnNumber="1"

pushToken() {
    if [[ -n "${tokens[-1]}" ]] || [[ -n "${tokens[-2]}" ]]; then
        # There's a token in the last slot in the tokens array, so make a new slot for the next one
        tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
        tokens+=("")
        tokens+=("")
    fi
    tokens[-2]="$1"
    tokens[-1]="$2"
    # Make a new slot for whatever happens next
    tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
    tokens+=("")
    tokens+=("")
}

insertToken() {
    local insertAfter="$1"
    local newTokenType="$2"
    local newToken="$3"
    local tokensTemp=("${tokens[@]:0:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("${tokens[$((insertAfter - 2))]}")
    tokensTemp+=("$newTokenType")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("$newToken")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("${tokens[@]:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokens=("${tokensTemp[@]}")
    #print_r "${tokens[@]}" >&2
}

# We need a dummy token at the beginning so we can insertToken after it (otherwise it would be inserting after something that doesn't exist)
tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
tokens+=("start-document")
tokens+=("")

# Add empty slots to the array for the first token
tokens+=("$lineNumber:$columnNumber:$currentIndentLevel") # Line/column/depth goes in first slot
tokens+=("") # Token type goes in second slot
tokens+=("") # Token content goes in third slot

while read -r byte; do
    byte=$(( 16#$byte )) # Convert to decimal
    if asciiIsNewline "$byte" || { [[ "$parserState" == "token" ]] && [[ "$byte" == "59" ]]; }; then
        pushToken newline ""
        lineNumber=$(( lineNumber + 1 ))
        columnNumber=1
    else
        columnNumber=$(( columnNumber + 1 ))
    fi
    #declare -p tokens >&2
    tokenCount="${#tokens[@]}" >&2
    comment='
    if [[ $lineNumber -eq 3 ]]; then
        set -x
    fi
    if [[ $lineNumber -eq 4 ]]; then
        die
    fi
    '
    case $parserState in
    token)
        if [[ "$countingIndentSpaces" == "true" ]]; then
            if asciiIsPrintable "$byte" && [[ "$byte" != "32" ]]; then
                if [[ $(( indentSpacesCounted % 4 )) -eq 0 ]] && [[ "$indentSpacesCounted" -lt $(( currentIndentLevel * 4 )) ]]; then
                    for (( i=0; i<=$(( currentIndentLevel - ( indentSpacesCounted / 4 ) )); i++ )); do
                        pushToken dedent ""
                        currentIndentLevel=$(( currentIndentLevel - 1 ))
                    done
                elif [[ "$indentSpacesCounted" -eq $(( currentIndentLevel * 4 )) ]]; then
                    true # The expected number of indent spaces was found; do nothing
                elif [[ "$indentSpacesCounted" -eq $(( ( currentIndentLevel + 1 ) * 4 )) ]]; then
                    pushToken "indent" ""
                    currentIndentLevel=$(( currentIndentLevel + 1 ))
                else
                    die "Found $indentSpacesCounted spaces on line $lineNumber, column $columnNumber, but the current indentation level would expect $(( currentIndentLevel * 4 )) spaces."
                fi
                countingIndentSpaces="false"
                indentSpacesCounted="0"
            elif [[ "$byte" == "32" ]]; then
                indentSpacesCounted=$(( indentSpacesCounted + 1 ))
            fi
        fi

        if asciiIsNewline "$byte"; then
            countingIndentSpaces="true"
        fi

        if asciiIsLetter "$byte" || asciiIsDigit "$byte" || [[ "$byte" == 45 ]] || [[ "$byte" == 47 ]]; then
            [[ -z "${tokens[-1]}" ]] && tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-1]="${tokens[-1]} $byte"
        elif asciiIsSpace "$byte"; then
            if [[ -n "${tokens[-1]}" ]]; then
                # End of token.
                # There's a token in the last slot in the tokens array, so make a new slot for the next one
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
        elif asciiIsNewline "$byte"; then
            # End of token
            if [[ -n "${tokens[-1]}" ]]; then
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
        elif [[ "$byte" == 39 ]]; then
            parserState="literal-s"
            tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-2]="literal-s"
        elif [[ "$byte" == 35 ]]; then
            parserState="comment"
            tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-2]="comment"
        else
            die "Unexpected byte $byte in basic token."
        fi
        ;;
    comment)
        if asciiIsNewline "$byte"; then
            parserState="token"
            if [[ -n "${tokens[-1]}" ]] || [[ -n "${tokens[-2]}" ]]; then
                # There's a token in the last slot in the tokens array, so make a new slot for the next one
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
            countingIndentSpaces="true"
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    literal-s)
        if [[ "$byte" == 39 ]]; then
            parserState="token"
            tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    *)
        die "Unknown parser state $parserState."
        ;;
    esac
done < <(hexdump -v -e '1/1 "%02X\n"' < "$input")

tempIndentLevel="$currentIndentLevel"
for (( i=0; i<tempIndentLevel; i++ )); do
    currentIndentLevel=$(( currentIndentLevel - 1 ))
    pushToken dedent ""
done

pushToken "end-document" ""
tokenCount="${#tokens[@]}"

# If there's an empty token slot at the end, remove it
if [[ -z "${tokens[-1]}" ]] && [[ -z "${tokens[-2]}" ]]; then
    unset 'tokens[-1]'
    unset 'tokens[-1]'
    unset 'tokens[-1]'
fi

# Not all the tokens are identified yet. So, now, let's label them all.

inParameterList="false"
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        if [[ -n "${tokens[$i - 1]+x}" ]] && [[ -z "${tokens[$i - 1]}" ]]; then
            # Set the token names in the table for these that aren't yet identified
            firstByte="${tokens[$i]:1}"
            if asciiIsDigit "${firstByte%% *}"; then
                tokens[$i - 1]="literal-n"
            else
                case "${tokens[$i]}" in
                " 114 47 110 47 "*)
                    tokens[$i - 1]="ident-r-n"
                    tokens[$i]="${tokens[$i]# 114 47 110 47}"
                    ;;
                " 114 47 115 47 "*)
                    tokens[$i - 1]="ident-r-s"
                    tokens[$i]="${tokens[$i]# 114 47 115 47}"
                    ;;
                " 114 47 97 110 47 "*)
                    tokens[$i - 1]="ident-r-arr-n"
                    tokens[$i]="${tokens[$i]# 114 47 97 110 47}"
                    ;;
                " 114 47 97 115 47 "*)
                    tokens[$i - 1]="ident-r-arr-s"
                    tokens[$i]="${tokens[$i]# 114 47 97 115 47}"
                    ;;
                " 110 47 "*)
                    tokens[$i - 1]="ident-n"
                    tokens[$i]="${tokens[$i]# 110 47}"
                    ;;
                " 115 47 "*)
                    tokens[$i - 1]="ident-s"
                    tokens[$i]="${tokens[$i]# 115 47}"
                    ;;
                " 97 110 47 "*)
                    tokens[$i - 1]="ident-arr-n"
                    tokens[$i]="${tokens[$i]# 97 110 47}"
                    ;;
                " 97 115 47 "*)
                    tokens[$i - 1]="ident-arr-s"
                    tokens[$i]="${tokens[$i]# 97 115 47}"
                    ;;
                *)
                    tokens[$i - 1]="command"
                    ;;
                esac
            fi
        fi
    fi
done

tokenCount="${#tokens[@]}"
# Convert command & number tokens' labels to strings instead of space-separated ASCII

for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        if [[ "${tokens[$i - 1]}" == "command" ]] || [[ "${tokens[$i - 1]}" == "literal-n" ]]; then
            tokens[$i]="$(asciiDecListToText <<< "${tokens[$i]}")"
        fi
    fi
done

tokenCount="${#tokens[@]}"
#declare -p tokens >&2
echo "Document contains $((tokenCount / 3)) tokens." >&2
for (( i=0; i<tokenCount; i++ )); do
    ! (( (i+1) % 3 )) && echo "Token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
done

# We now know what each token is, so let's do the code generation.

if [[ "$targetLang" == "parsed" ]]; then
    # Just dump the parse results and exit
    for (( i=0; i<tokenCount; i++ )); do
        ! (( (i+1) % 3 )) && echo "${tokens[$i - 1]} ${tokens[$i]}"
    done
    true
    exit
fi

codegenIndent=0
codegenRoutineType=""
codegenRoutineName=""
codegenArgList=()

# Define a function for each type of output needed for code generation

codegenDebug() {
    echo "Codegen: $1, routine $codegenRoutineType:$codegenRoutineName / Args: ${@} / States: ${stateStack[@]} / Blocks: ${blockStack[@]}." >&2
}

codegenType() {
    codegenDebug "Type" "${@}" >&2
    # First arg: type; second arg: "true" for uppercase first letter
    local result=""
    case "$targetLang" in
    "js")
        [[ "$1" == "ident-s" ]] && result='str'
        [[ "$1" == "ident-n" ]] && result='int'
        [[ "$1" == "ident-arr-s" ]] && result='strArray'
        [[ "$1" == "ident-arr-n" ]] && result='intArray'
        [[ "$1" == "ident-r-s" ]] && result='str'
        [[ "$1" == "ident-r-n" ]] && result='int'
        [[ "$1" == "ident-r-arr-s" ]] && result='strArray'
        [[ "$1" == "ident-r-arr-n" ]] && result='intArray'
        #[[ -z "$result" ]] && result="$1"
        [[ -z "$result" ]] && die "$1 is not a recognized type!"
        if [[ "$2" == "true" ]]; then
            print "${result^}"
        else
            print "$result"
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenLiteral() {
    codegenDebug "Literal" "${@}" >&2
    # First arg: type; second arg: value
    case "$targetLang" in
    "js")
        case "$1" in
        "literal-s")
            print \'"$(asciiDecListToText "$2")"\'
            ;;
        "literal-n")
            print "$2"
            ;;
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenReference() {
    codegenDebug "Reference" "${@}" >&2
    # First arg: type; second arg: value
    case "$targetLang" in
    "js")
        codegenType "$1"
        print "${2^}"
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenPrintIndentationSpaces() {
    [[ "$testParameterFound" == "indent-deferred" ]] && codegenIndent=$(( codegenIndent - 1 ))
    for (( j=0; j<codegenIndent; j++ )); do
        print '    '
    done
    [[ "$testParameterFound" == "indent-deferred" ]] && codegenIndent=$(( codegenIndent + 1 ))
    true
}

codegenStartDocument() {
    codegenDebug "Start document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndDocument() {
    codegenDebug "End document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIndent() {
    codegenDebug "Indent" "${@}" >&2
    case "$targetLang" in
    "js")
        [[ "${stateStack[-1]}" == "code" ]] || print ' '
        print '{'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenDedent() {
    codegenDebug "Dedent" "${@}" >&2
    codegenIndent=$(( codegenIndent - 1 ))
    codegenPrintIndentationSpaces
    codegenIndent=$(( codegenIndent + 1 ))
    case "$targetLang" in
    "js")
        print '}'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenComment() {
    codegenDebug "Comment" "${@}" >&2
    codegenPrintIndentationSpaces
    case "$targetLang" in
    "js")
        print "/*""$1 */"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenGetCurrentRoutineType() {
    local counter="${#blockStack[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if ( codegenType "${blockStack[$counter]}" &> /dev/null; ); then
            print "${blockStack[$counter]}"
            return 0
        fi
        counter=$(( counter - 1 ))
    done
}

codegenCommandInvocationStart() {
    codegenDebug "Command invocation start" "${@}" >&2
    case "$codegenRoutineName" in
    new)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            print "let "
            codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            print ";"$'\n'
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    return)
        print $'\n'
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            local returnType
            returnType="$(codegenGetCurrentRoutineType)" || true
            [[ -z "$returnType" ]] && die "Tried to return, but was not inside a routine!"
            codegenType "$returnType"
            print "Return = "
            codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            print "; await assertIs"
            codegenType "$returnType" true
            print "("
            codegenType "$returnType"
            print "Return); return "
            codegenType "$returnType"
            print "Return;"$'\n'
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    set)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            if [[ "${codegenArgList[-4]+a}" ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                print '='
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                print ";"$'\n'
            else
                # It's getting set to a command's return value
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                print '='
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    if)
        codegenPrintIndentationSpaces
        print "if ("
        ;;
    add|eq|mod)
        # These commands are implemented with impl* calls
        case "$targetLang" in
        "js")
            print "await impl${codegenRoutineName^}("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            print "await $codegenRoutineName("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationArgSeparator() {
    codegenDebug "Command invocation argument separator" "${@}" >&2
    case "$targetLang" in
    "js")
        print ", "
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenCommandInvocationArglist() {
    codegenDebug "Command invocation argument list" "${@}" >&2
    case "$targetLang" in
    "js")
        argumentCount="${#codegenArgList[@]}"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                if [[ "${codegenArgList[$k - 1]}" == literal-* ]]; then
                    codegenLiteral "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                else
                    codegenReference "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                fi
                if [[ "$k" != $((argumentCount - 1)) ]]; then
                    codegenCommandInvocationArgSeparator
                fi
            fi
        done
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationEnd() {
    codegenDebug "Command invocation end" "${@}" >&2
    case "$codegenRoutineName" in
    return|new)
        # This shouldn't happen, because it's all handled in codegenCommandInvocationStart
        die "Internal error (this is a bug): codegenCommandInvocationEnd called for return"
        ;;
    add|eq|mod)
        # These commands are implemented with impl* calls
        case "$targetLang" in
        "js")
            print ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        #codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            print ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    if ! contains "test" "${stateStack[@]}"; then
        print ';'$'\n'
    fi
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionStart() {
    codegenDebug "Routine definition start" "${@}" >&2
    case "$targetLang" in
    "js")
        print "async function $codegenRoutineName("
        argumentCount="${#codegenArgList[@]}"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenType "${codegenArgList[$k - 1]}"
                if [[ "$k" == $((argumentCount - 1)) ]]; then
                    print "${codegenArgList[$k]^}"
                else
                    print "${codegenArgList[$k]^}, "
                fi
            fi
        done
        print ") {"$'\n'
        codegenIndent=$(( codegenIndent + 1 ))
        codegenPrintIndentationSpaces
        codegenIndent=$(( codegenIndent - 1 ))
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                print "await assertIs"
                codegenType "${codegenArgList[$k - 1]}" "true"
                print "("
                codegenType "${codegenArgList[$k - 1]}"
                print "${codegenArgList[$k]^}"
                if [[ "$k" == $((argumentCount - 1)) ]] && [[ "${codegenArgList[$k - 1]}" == "void" ]]; then
                    print ");"
                else
                    print "); "
                fi
            fi
        done
        if [[ "${codegenArgList[$k - 1]}" != "void" ]]; then
            print "let "
            codegenType "$codegenRoutineType"
            print "Return;"$'\n\n'
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    "js")
        # print "}"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIsTestCommand() {
    case "$1" in
    for|if|until|while)
        true
        ;;
    *)
        false
        ;;
    esac
}

# Set up the variables we'll need for going through the tokens and generating the code

stateStack=("root" "code")
blockStack=("root" "")
testParameterFound="false"
set -x
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        codegenIndent="${tokens[$i - 2]##*:}"

        #echo >&2
        #echo "i=$i" >&2
        #declare -p tokens >&2
        #declare -p stateStack >&2
        echo "State: ${stateStack[-1]}:$codegenIndent, token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
        #declare -p stateStack >&2

        if [[ "${tokens[$i - 1]}" == "comment" ]]; then
            echo "(Inserting a comment)" >&2
            codegenComment "$(asciiDecListToText "${tokens[$i]}")"
        else
            case "${stateStack[-1]}" in
            code)
                echo "Working on code" >&2
                case "${tokens[$i - 1]}" in
                start-document)
                    codegenStartDocument
                    ;;
                end-document)
                    codegenEndDocument
                    ;;
                indent)
                    codegenIndent
                    stateStack+=("code")
                    ;;
                dedent)
                    codegenDedent
                    unset 'stateStack[-1]'
                    ;;
                ident-r-*)
                    codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                    if [[ "${tokens[$i - 4]}" != "start-document" ]]; then
                    declare -p tokens >&2
                        print $'\n'
                    fi
                    codegenRoutineType="${tokens[$i - 1]}"
                    stateStack+=("routine-definition")
                    blockStack+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command)
                    codegenRoutineName="${tokens[$i]}"
                    case "${tokens[$i]}" in
                    new|return|set)
                        stateStack+=("oneshot-command")
                        ;;
                    for|if|until|while)
                        stateStack+=("test")
                        blockStack+=("test" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    *)
                        codegenCommandInvocationStart
                        stateStack+=("arglist")
                        ;;
                    esac
                    ;;
                newline)
                    ;;
                *)
                    die "A ${tokens[$i - 1]}, ${tokens[$i]}, isn't allowed here, in ${blockStack[-1]}."
                    ;;
                esac
                ;;
            oneshot-command)
                case "${tokens[$i - 1]}" in
                literal-*)
                    # Some type of data, literal.
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                *)
                    # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                    codegenCommandInvocationStart
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                esac
                ;;
            arglist|test)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                literal-*)
                    # Some type of data, literal.
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                ident-*)
                    # Some type of data, reference.
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                command)
                    if [[ "${tokens[$i]}" == "return" ]] || { [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] ; }; then
                        # The arglist is ended, so drop back and continue parsing.
                        #echo "ENDEDE ARGE LIST" >&2
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                        codegenIndent
                        #stateStack+=("code")
                    else
                        if [[ "${stateStack[-1]}" != "test" ]]; then
                            codegenCommandInvocationArglist
                            codegenIsTestCommand "${tokens[$i - 3]}" || codegenCommandInvocationArgSeparator
                        fi
                        codegenRoutineName="${tokens[$i]}"
                        codegenCommandInvocationStart
                        if [[ "${stateStack[-1]}" == "test" ]]; then
                            testParameterFound="true"
                            #codegenIsTestCommand "${tokens[$i - 3]}" || codegenPrintIndentationSpaces
                        fi
                        stateStack+=("arglist")
                    fi
                    ;;
                indent)
                    if [[ "$testParameterFound" == "true" ]]; then
                        testParameterFound="false"
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                    elif [[ "$testParameterFound" == "indent-deferred" ]]; then
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    else
                        print $'\n'
                        codegenIndent=$(( codegenIndent + 1 ))
                        codegenPrintIndentationSpaces
                        codegenIndent=$(( codegenIndent - 1 ))
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="indent-deferred"
                    fi
                    ;;
                newline)
                    if [[ "${stateStack[-1]}" != "test" ]]; then
                        if [[ "$testParameterFound" == "true" ]]; then
                            # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                            codegenCommandInvocationArglist
                            codegenCommandInvocationEnd
                            unset 'stateStack[-1]'
                            i=$((i - 3))
                        fi
                    fi
                    ;;
                *)
                    # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    testParameterFound="false"
                    codegenIndent
                    stateStack+=("code")
                    ;;
                esac
                ;;
            routine-definition)
                echo "Working on routine definition" >&2
                # Format: token, [ident...], code body
                # So now we look for as many types as there are. When no more types, it enters the code body of the routine. When there's a dedent, it leaves the code body of the routine.
                case "${tokens[$i - 1]}" in
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent|newline)
                    # The routine definition parameter list is ended, so do codegen for the routine declaration (but not the body of it), and continue parsing.
                    codegenRoutineDefinitionStart
                    stateStack[-1]="routine-definition-end"
                    stateStack+=("code")
                    # Avoid putting in an extra code level
                    [[ "${tokens[$i - 1]}" == "newline" ]] && [[ "${tokens[$i + 2]}" == "indent" ]] && i=$((i + 3))
                    ;;
                *)
                    die "Routine definition unexpected token type"
                esac
                ;;
            routine-definition-end)
                echo "Working on routine definition end" >&2
                unset 'stateStack[-1]'
                codegenRoutineDefinitionEnd
                unset 'blockStack[-1]'
                unset 'blockStack[-1]'
                ;;
            root)
                true
                ;;
            *)
                die "Unimplemented code generation state ${stateStack[-1]}"
                ;;
            esac
        fi
    fi
done

print_r "${stateStack[@]}" >&2
print_r "${blockStack[@]}" >&2
