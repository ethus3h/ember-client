#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
#set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes a StageL file as first argument, and prints out equivalent code in the language of the second argument (bash/js).

input="$1"
targetLang="$2"

tokens=()

# First, break up the input into tokens in the tokens array. This doesn't support streaming, so isn't good for long documents, but should suffice for now. The format should be streamable to other formats; this was just easier to implement for now.

pushToken() {
    if [[ -n "${tokens[-1]}" ]]; then
        # There's a token in the last slot in the tokens array, so make a new slot for the next one
        tokens+=("")
        tokens+=("")
    fi
    tokens[-2]="$1"
    tokens[-1]="$2"
    # Make a new slot for whatever happens next
    tokens+=("")
    tokens+=("")
}

insertToken() {
    local insertAfter="$1"
    local newTokenType="$2"
    local newToken="$3"
    local tokensTemp=("${tokens[@]:0:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("$newTokenType")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("$newToken")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("${tokens[@]:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokens=("${tokensTemp[@]}")
    #print_r "${tokens[@]}" >&2
}

# We need a dummy token at the beginning so we can insertToken after it (otherwise it would be inserting after something that doesn't exist)
tokens+=("start-document")
tokens+=("")

# Add empty slots to the array for the first token
tokens+=("") # Token type goes in even numbered slots
tokens+=("") # Token content goes in odd numbered slots

parserState="token"
prevByte=""
currentIndentLevel="0"
countingIndentSpaces="true"
indentSpacesCounted="0"
lineNumber="1"
columnNumber="1"

while read -r byte; do
    byte=$(( 16#$byte )) # Convert to decimal
    if asciiIsNewline "$byte"; then
        lineNumber=$(( lineNumber + 1 ))
        columnNumber=1
    else
        columnNumber=$(( columnNumber + 1 ))
    fi
    tokenCount="${#tokens[@]}" >&2
    case $parserState in
    token)
        if [[ "$countingIndentSpaces" == "true" ]]; then
            if asciiIsPrintable "$byte" && [[ "$byte" != "32" ]]; then
                countingIndentSpaces="false"
                if [[ "$indentSpacesCounted" -eq $(( ( currentIndentLevel - 1 ) * 4 )) ]]; then
                    pushToken "dedent" ""
                    currentIndentLevel=$(( currentIndentLevel - 1 ))
                elif [[ "$indentSpacesCounted" -eq $(( currentIndentLevel * 4 )) ]]; then
                    true # The expected number of indent spaces was found; do nothing
                elif [[ "$indentSpacesCounted" -eq $(( ( currentIndentLevel + 1 ) * 4 )) ]]; then
                    pushToken "indent" ""
                    currentIndentLevel=$(( currentIndentLevel + 1 ))
                else
                    die "Found $indentSpacesCounted spaces on line $lineNumber, column $columnNumber, but the current indentation level would expect $(( currentIndentLevel * 4 )) spaces."
                fi
            elif [[ "$byte" == "32" ]]; then
                indentSpacesCounted=$(( indentSpacesCounted + 1 ))
            fi
        fi

        if asciiIsNewline "$byte"; then
            countingIndentSpaces="true"
        fi

        if asciiIsLetter "$byte" || [[ "$byte" == 47 ]]; then
            tokens[-1]="${tokens[-1]} $byte"
        elif asciiIsSpace "$byte"; then
            if [[ -n "${tokens[-1]}" ]]; then
                # End of token.
                # There's a token in the last slot in the tokens array, so make a new slot for the next one
                tokens+=("")
                tokens+=("")
            fi
        elif asciiIsNewline "$byte"; then
            # End of token
            if [[ -n "${tokens[-1]}" ]]; then
                tokens+=("")
                tokens+=("")
            fi
        elif [[ "$byte" == 39 ]]; then
            parserState="literal-s"
            tokens[-2]="literal-s"
        elif [[ "$byte" == 35 ]]; then
            parserState="comment"
            tokens[-2]="comment"
        else
            die "Unexpected byte $byte in basic token."
        fi
        prevByte="$byte"
        ;;
    comment)
        if asciiIsNewline "$byte"; then
            parserState="token"
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    literal-s)
        if [[ "$byte" == 39 ]]; then
            parserState="token"
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    *)
        die "Unknown parser state $parserState."
        ;;
    esac
done < <(hexdump -v -e '1/1 "%02X\n"' < "$input")

for (( i=0; i<currentIndentLevel; i++ )); do
    pushToken dedent ""
done

pushToken "end-document" ""

# Not all the tokens are identified yet. So, now, let's label them all.

tokenCount="${#tokens[@]}"

inParameterList="false"
for (( i=0; i<tokenCount; i++ )); do
    if (( i % 2 )); then
        if [[ -z "${tokens[$i - 1]}" ]]; then
            if [[ "${tokens[$i]}" == " 114 47 "* ]]; then
                # It's a routine identifier, either invocation or declaration
                if [[ "${tokens[$i - 3]}" != "command" ]] && [[ "${tokens[$i - 2]}" != "run" ]]; then
                    # It's not being run, so it's not an invocation, meaning it must be a declaration of this routine. So, insert an indent token, and set the state that we want to find the end of the param list and then dedent
                    insertToken "$((i + 1))" "indent" ""
                    inParameterList="true"
                fi
            fi
            if [[ "$inParameterList" == "true" ]]; then
                # Ok, let's see if we've found the end of the parameter list: if the current token is anything but a non-routine identifier, it's the end of the param list, so dedent
                if [[ "${tokens[$i + 3]}" != " 110 47 "* ]]; then
                    # It's the end of the parameter list (TODO: right now, this only tests for numbers)
                    inParameterList="false"
                    insertToken "$((i + 5))" "dedent" ""
                fi
            fi
            # Set the token names in the table for these that aren't yet identified
            case "${tokens[$i]}" in
            " 114 47 115 47 "*)
                tokens[$i - 1]="ident-r-s"
                tokens[$i]="${tokens[$i]# 114 47 115 47}"
                ;;
            " 110 47 "*)
                tokens[$i - 1]="ident-n"
                tokens[$i]="${tokens[$i]# 110 47}"
                ;;
            *)
                tokens[$i - 1]="command"
                ;;
            esac
        fi
    fi
done

# Identify command tokens, and their associated parameter lists.
# Possible commands:
# run [routine-identifier] [parameters-for-routine (literals or references)]
# ...

# If there's an empty token slot at the end, remove it
if [[ -z "${tokens[-1]}" ]] && [[ -z "${tokens[-2]}" ]]; then
    unset 'tokens[-1]'
    unset 'tokens[-2]'
fi

tokenCount="${#tokens[@]}"
echo "Document contains $((tokenCount / 2)) tokens." >&2
for (( i=0; i<tokenCount; i++ )); do
    (( i % 2 )) && echo "Token #$i: ${tokens[$i - 1]}: ${tokens[$i]}" >&2
done

# We now know what each token is, so let's do the code generation.

if [[ "$targetLang" == "parsed" ]]; then
    # Just dump the parse results and exit
    for (( i=0; i<tokenCount; i++ )); do
        (( i % 2 )) && echo "${tokens[$i - 1]} ${tokens[$i]}"
    done
    exit
fi

indentationLevel=0
stateStack=("code")
blockStack=("root")

for (( i=0; i<tokenCount; i++ )); do
    if (( i % 2 )); then
        echo "${stateStack[-1]}" >&2
        case "${stateStack[-1]}" in
        code)
            case "${tokens[$i - 1]}" in
            ident-r-*)
                indentationLevel=$((indentationLevel + 1))
                stateStack+=("routine-definition")
                blockStack+=("${tokens[$i]}")
                insertToken "$i" "r-def-arglist-start" "e"
                ;;
            ident-n)
                ;;
            *)
                tokens[$i - 1]="command"
                ;;
            esac
            ;;
        routine-definition)
            # Format: token, [type...], code body
            # So now we look for as many types as there are. When no more types, it enters the code body of the routine. When there's a dedent, it leaves the code body of the routine.
            case "${tokens[$i - 1]}" in
            ident-n)
                echo "Routine ${tokens[$i - 2]} has an integer argument"
                ;;
            dedent)
                # This routine dedented without having any body declared.
                warn "The routine ${blockStack[-1]} does not have a body declared."
                indentationLevel=$((indentationLevel - 1))
                unset 'stateStack[-1]'
                unset 'blockStack[-1]'
                ;;
            command)
                stateStack[-1]="routine-definition-body"
                # A token in the body of the routine
                echo "Token of routine ${blockStack[-1]} body: ${tokens[$i - 1]}: ${tokens[$i]}"
                # We need to parse its argument list, now.
                stateStack+=("argument-list")
                insertToken "$i" "r-def-arglist-end" "e" # e for empty, since there isn't really a token value for this but if it were actually empty it would be considered not a token in other checks.
                insertToken "$((i + 2))" "r-call-arglist-start" "e"
                ;;
            comment)
                # It's a comment.
                echo "Comment: ${tokens[$i]}"
                ;;
            *)
                die "Expected data ident, dedent, command, or comment in routine definition of ${blockStack[-1]}; found ${tokens[$i - 1]}: ${tokens[$i]} instead."
                ;;
            esac
            ;;
        routine-definition-body)
            case "${tokens[$i - 1]}" in
            command)
                # A token in the body of the routine
                echo "Token of routine ${blockStack[-1]} body: ${tokens[$i - 1]}: ${tokens[$i]}"
                # We need to parse its argument list, now.
                stateStack+=("argument-list")
                ;;
            dedent)
                # Found the end of the routine body.
                indentationLevel=$((indentationLevel - 1))
                unset 'stateStack[-1]'
                unset 'blockStack[-1]'
                ;;
            comment)
                # It's a comment.
                echo "Comment: ${tokens[$i]}"
                ;;
            ident-r-*)
                echo "Entered routine definition for ${tokens[$i]}."
                indentationLevel=$((indentationLevel + 1))
                stateStack+=("routine-definition")
                blockStack+=("${tokens[$i]}")
                ;;
            *)
                die "Expected command, dedent, routine definition, or comment in body of ${blockStack[-1]}; found ${tokens[$i - 1]}: ${tokens[$i]} instead."
                ;;
            esac
            ;;
       argument-list)
            case "${tokens[$i - 1]}" in
            literal-*)
                # A token in the body of the routine
                echo "Token of routine ${blockStack[-1]} body: ${tokens[$i - 1]}: ${tokens[$i]}"
                # We need to parse its argument list, now.
                stateStack+=("argument-list")
                ;;
            ident-r-*)
                # The command owning the arglist being parsed must be "run". So we'll parse its arglist too.
                assert equals "${tokens[$i]}" "run"
                stateStack+=("argument-list")
                ;;
            ident-*)
                # Some type of data.
                ;;
            command)
                # A command is being used to get its value.
                ;;
            comment)
                # It's a comment.
                echo "Comment: ${tokens[$i]}"
                ;;
            *)
                die "Expected literal, identifier, routine name, or comment in argument list of ${blockStack[-1]}; found ${tokens[$i - 1]}: ${tokens[$i]} instead."
                ;;
            esac
            ;;
        *)
            die "Unimplemented code generation state ${stateStack[-1]}"
            ;;
        esac
    fi
done

print_r "${stateStack[@]}" >&2
print_r "${blockStack[@]}" >&2
