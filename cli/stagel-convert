#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes a StageL file as first argument, and prints out equivalent code in the language of the second argument (bash/js).

input="$1"
targetLang="$2"

tokens=()
# Add empty slots to the array for the first token
tokens+=("") # Token type goes in even numbered slots
tokens+=("") # Token content goes in odd numbered slots
parserState="token"

# First, break up the input into tokens in the tokens array. This doesn't support streaming, so isn't good for long documents, but should suffice for now. The format should be streamable to other formats.

while read -r byte; do
    byte=$(( 16#$byte )) # Convert to decimal
    case $parserState in
    token)
        if asciiIsLetter "$byte" || [[ "$byte" == 47 ]]; then
            tokens[-1]="${tokens[-1]} $byte"
        elif asciiIsSpace "$byte"; then
            # End of token
            tokens+=("")
            tokens+=("")
        elif asciiIsNewline "$byte"; then
            # End of token
            tokens+=("")
            tokens+=("")
        elif [[ "$byte" == 39 ]]; then
            parserState="literal-str"
            tokens[-2]="literal-str"
        elif [[ "$byte" == 35 ]]; then
            parserState="comment"
            tokens[-2]="comment"
        else
            die "Unexpected byte $byte in basic token."
        fi
        ;;
    comment)
        if asciiIsNewline "$byte"; then
            parserState="token"
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    literal-str)
        if [[ "$byte" == 39 ]]; then
            parserState="token"
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    *)
        die "Unknown parser state $parserState."
        ;;
    esac
done < <(hexdump -v -e '1/1 "%02X\n"' < "$input")

# Not all the tokens are identified yet. So, now, let's label them all.

tokenCount="${#tokens[@]}"

echo "Printing $((tokenCount / 2)) tokens."
for (( i=0; i<tokenCount; i++ )); do
    (( i % 2 )) && echo "Token #$i: ${tokens[$i - 1]}: ${tokens[$i]}"
done

print_r "${tokens[@]}"
