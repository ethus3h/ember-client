#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null || { printf '%b' '\033[1;31m' >&2; echo "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd): The required dependency ember-shared could not be found (or ember_bash_setup could not be sourced for some other reason)." >&2; printf '%b' '\033[0m' >&2; exit 1; }
#set -x

trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

# Takes a StageL file as first argument, and prints out equivalent code in the language of the second argument (bash/js).
# FIXME: unit tests; literal bools; elif; int32 in 8 bit cpu; comparison of bit operations by programming language; ceil/floor with negative numbers; effects of endianness; are script tags executed in order

input="$1"
filename="$(basename "$input")"
filename="${filename//.stagel}" # Don't include extension in name when displaying it in backtraces
targetLang="$2"

tokens=()

# First, break up the input into tokens in the tokens array. This doesn't support streaming, so isn't good for long documents, but should suffice for now. The format should be streamable to other formats; this was just easier to implement for now.

parserState="token"
currentIndentLevel="0"
countingIndentSpaces="true"
indentSpacesCounted="0"
lineNumber="1"
columnNumber="1"

pushToken() {
    if [[ -n "${tokens[-1]}" ]] || [[ -n "${tokens[-2]}" ]]; then
        # There's a token in the last slot in the tokens array, so make a new slot for the next one
        tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
        tokens+=("")
        tokens+=("")
    fi
    tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
    tokens[-2]="$1"
    tokens[-1]="$2"
    # Make a new slot for whatever happens next
    tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
    tokens+=("")
    tokens+=("")
}

insertToken() {
    local insertAfter="$1"
    local newTokenType="$2"
    local newToken="$3"
    local tokensTemp=("${tokens[@]:0:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("${tokens[$((insertAfter - 2))]}")
    tokensTemp+=("$newTokenType")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("$newToken")
    #print_r "${tokensTemp[@]}" >&2
    tokensTemp+=("${tokens[@]:insertAfter}")
    #print_r "${tokensTemp[@]}" >&2
    tokens=("${tokensTemp[@]}")
    #print_r "${tokens[@]}" >&2
}

# We need a dummy token at the beginning so we can insertToken after it (otherwise it would be inserting after something that doesn't exist)
tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
tokens+=("start-document")
tokens+=("")

# Add empty slots to the array for the first token
tokens+=("$lineNumber:$columnNumber:$currentIndentLevel") # Line/column/depth goes in first slot
tokens+=("") # Token type goes in second slot
tokens+=("") # Token content goes in third slot
#set -x
while read -r byte; do
    byte=$(( 16#$byte )) # Convert to decimal
    if asciiIsNewline "$byte" || { [[ "$parserState" == "token" ]] && [[ "$byte" == "59" ]]; }; then
        pushToken newline ""
        lineNumber=$(( lineNumber + 1 ))
        columnNumber=1
    else
        columnNumber=$(( columnNumber + 1 ))
    fi
    #declare -p tokens >&2
    tokenCount="${#tokens[@]}" >&2
    comment='
    if [[ $lineNumber -eq 3 ]]; then
        set -x
    fi
    if [[ $lineNumber -eq 4 ]]; then
        die
    fi
    '
    case $parserState in
    token)
        if [[ "$countingIndentSpaces" == "true" ]]; then
            if asciiIsPrintable "$byte" && [[ "$byte" != "32" ]]; then
                if [[ $(( indentSpacesCounted % 4 )) -eq 0 ]] && [[ "$indentSpacesCounted" -lt $(( currentIndentLevel * 4 )) ]]; then
                    #set -x
                    tempIndentLevelDedentState=$(( currentIndentLevel - ( indentSpacesCounted / 4 ) ))
                    for (( i=0; i<tempIndentLevelDedentState; i++ )); do
                        currentIndentLevel=$(( currentIndentLevel - 1 ))
                        pushToken dedent ""
                    done
                    #set +x
                elif [[ "$indentSpacesCounted" -eq $(( currentIndentLevel * 4 )) ]]; then
                    true # The expected number of indent spaces was found; do nothing
                elif [[ "$indentSpacesCounted" -eq $(( ( currentIndentLevel + 1 ) * 4 )) ]]; then
                    pushToken "indent" ""
                    currentIndentLevel=$(( currentIndentLevel + 1 ))
                else
                    die "Found $indentSpacesCounted spaces on line $lineNumber, column $columnNumber, but the current indentation level would expect $(( currentIndentLevel * 4 )) spaces."
                fi
                countingIndentSpaces="false"
                indentSpacesCounted="0"
            elif [[ "$byte" == "32" ]]; then
                indentSpacesCounted=$(( indentSpacesCounted + 1 ))
            fi
        fi

        if asciiIsNewline "$byte"; then
            countingIndentSpaces="true"
        fi

        if asciiIsLetter "$byte" || asciiIsDigit "$byte" || [[ "$byte" == 45 ]] || [[ "$byte" == 47 ]]; then
            [[ -z "${tokens[-1]}" ]] && tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-1]="${tokens[-1]} $byte"
        elif asciiIsSpace "$byte"; then
            if [[ -n "${tokens[-1]}" ]]; then
                # End of token.
                # There's a token in the last slot in the tokens array, so make a new slot for the next one
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
        elif asciiIsNewline "$byte"; then
            # End of token
            if [[ -n "${tokens[-1]}" ]]; then
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
        elif [[ "$byte" == 39 ]]; then
            parserState="literal-s"
            tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-2]="literal-s"
        elif [[ "$byte" == 60 ]]; then
            pushToken literal-ab-start ""
        elif [[ "$byte" == 62 ]]; then
            pushToken literal-ab-end ""
        elif [[ "$byte" == 40 ]]; then
            pushToken literal-an-start ""
        elif [[ "$byte" == 41 ]]; then
            pushToken literal-an-end ""
        elif [[ "$byte" == 91 ]]; then
            pushToken literal-as-start ""
        elif [[ "$byte" == 93 ]]; then
            pushToken literal-as-end ""
        elif [[ "$byte" == 35 ]]; then
            parserState="comment"
            tokens[-3]="$lineNumber:$columnNumber:$currentIndentLevel"
            tokens[-2]="comment"
        else
            die "Unexpected byte $byte in basic token."
        fi
        ;;
    comment)
        if asciiIsNewline "$byte"; then
            parserState="token"
            if [[ -n "${tokens[-1]}" ]] || [[ -n "${tokens[-2]}" ]]; then
                # There's a token in the last slot in the tokens array, so make a new slot for the next one
                tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
                tokens+=("")
                tokens+=("")
            fi
            countingIndentSpaces="true"
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a comment."
        fi
        ;;
    literal-s)
        if [[ "$byte" == 39 ]]; then
            parserState="token"
            tokens+=("$lineNumber:$columnNumber:$currentIndentLevel")
            tokens+=("")
            tokens+=("")
        elif asciiIsPrintable "$byte"; then
            tokens[-1]="${tokens[-1]} $byte"
        else
            die "Non-printable byte $byte in a string literal."
        fi
        ;;
    *)
        die "Unknown parser state $parserState."
        ;;
    esac
done < <(hexdump -v -e '1/1 "%02X\n"' < "$input")

tempIndentLevel="$currentIndentLevel"
for (( i=0; i<tempIndentLevel; i++ )); do
    currentIndentLevel=$(( currentIndentLevel - 1 ))
    pushToken dedent ""
done

pushToken "end-document" ""
tokenCount="${#tokens[@]}"

# If there's an empty token slot at the end, remove it
if [[ -z "${tokens[-1]}" ]] && [[ -z "${tokens[-2]}" ]]; then
    unset 'tokens[-1]'
    unset 'tokens[-1]'
    unset 'tokens[-1]'
fi

# Not all the tokens are identified yet. So, now, let's label them all.

inParameterList="false"
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        if [[ -n "${tokens[$i - 1]+x}" ]] && [[ -z "${tokens[$i - 1]}" ]]; then
            # Set the token names in the table for these that aren't yet identified
            firstByte="${tokens[$i]:1}"
            if asciiIsDigit "${firstByte%% *}"; then
                tokens[$i - 1]="literal-n"
            else
                case "${tokens[$i]}" in
                " 114 47 98 47 "*)
                    tokens[$i - 1]="ident-r-b"
                    tokens[$i]="${tokens[$i]# 114 47 98 47}"
                    ;;
                " 114 47 110 47 "*)
                    tokens[$i - 1]="ident-r-n"
                    tokens[$i]="${tokens[$i]# 114 47 110 47}"
                    ;;
                " 114 47 115 47 "*)
                    tokens[$i - 1]="ident-r-s"
                    tokens[$i]="${tokens[$i]# 114 47 115 47}"
                    ;;
                " 114 47 118 47 "*)
                    tokens[$i - 1]="ident-r-v"
                    tokens[$i]="${tokens[$i]# 114 47 118 47}"
                    ;;
                " 114 47 97 98 47 "*)
                    tokens[$i - 1]="ident-r-ab"
                    tokens[$i]="${tokens[$i]# 114 47 97 98 47}"
                    ;;
                " 114 47 97 110 47 "*)
                    tokens[$i - 1]="ident-r-an"
                    tokens[$i]="${tokens[$i]# 114 47 97 110 47}"
                    ;;
                " 114 47 97 115 47 "*)
                    tokens[$i - 1]="ident-r-as"
                    tokens[$i]="${tokens[$i]# 114 47 97 115 47}"
                    ;;
                " 98 47 "*)
                    tokens[$i - 1]="ident-b"
                    tokens[$i]="${tokens[$i]# 98 47}"
                    ;;
                " 103 47 "*)
                    tokens[$i - 1]="ident-g"
                    tokens[$i]="${tokens[$i]# 103 47}"
                    ;;
                " 110 47 "*)
                    tokens[$i - 1]="ident-n"
                    tokens[$i]="${tokens[$i]# 110 47}"
                    ;;
                " 115 47 "*)
                    tokens[$i - 1]="ident-s"
                    tokens[$i]="${tokens[$i]# 115 47}"
                    ;;
                " 97 98 47 "*)
                    tokens[$i - 1]="ident-ab"
                    tokens[$i]="${tokens[$i]# 97 98 47}"
                    ;;
                " 97 110 47 "*)
                    tokens[$i - 1]="ident-an"
                    tokens[$i]="${tokens[$i]# 97 110 47}"
                    ;;
                " 97 115 47 "*)
                    tokens[$i - 1]="ident-as"
                    tokens[$i]="${tokens[$i]# 97 115 47}"
                    ;;
                " 103 97 47 "*)
                    tokens[$i - 1]="ident-ga"
                    tokens[$i]="${tokens[$i]# 103 97 47}"
                    ;;
                " 103 105 47 "*)
                    tokens[$i - 1]="ident-gi"
                    tokens[$i]="${tokens[$i]# 103 105 47}"
                    ;;
                " 116 114 117 101")
                    tokens[$i - 1]="literal-b"
                    tokens[$i]="true"
                    ;;
                " 102 97 108 115 101")
                    tokens[$i - 1]="literal-b"
                    tokens[$i]="false"
                    ;;
                *)
                    tokens[$i - 1]="command"
                    ;;
                esac
            fi
        fi
    fi
done

tokenCount="${#tokens[@]}"
# Convert command & number tokens' labels to strings instead of space-separated ASCII

for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        if [[ "${tokens[$i - 1]}" == "command" ]] || [[ "${tokens[$i - 1]}" == "literal-n" ]]; then
            tokens[$i]="$(asciiDecListToText <<< "${tokens[$i]}")"
        fi
    fi
done

tokenCount="${#tokens[@]}"
#declare -p tokens >&2
echo "Document contains $((tokenCount / 3)) tokens." >&2
for (( i=0; i<tokenCount; i++ )); do
    ! (( (i+1) % 3 )) && echo "Token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)" >&2
done

# We now know what each token is, so let's do the code generation.

if [[ "$targetLang" == "parsed" ]]; then
    # Just dump the parse results and exit
    for (( i=0; i<tokenCount; i++ )); do
        echo "${tokens[$i]}"
    done
    true
    exit
fi

# Set up the variables we'll need for going through the tokens and generating the code

codegenIndent=0
codegenLastKnownArglistCount=0
codegenRoutineType=""
codegenRoutineName=""
codegenArgList=()
codegenNewLine="true"
codegenNewlineLookingForSpaces="true" # True while finding indentation spaces at the beginning of a line.
codegenTestIndentDeferred="false" # True while waiting to come to the code-block portion of a "test"-style construct (e.g. "if") that has a multiline test part
stateStack=("root" "code")
blockStack=("root" "")
testParameterFound="false" # This is set to "false" usually. When a token that uses a "test" syntax (e.g. if, or any other thing that first takes a value and also starts a code block) is encountered, it stays false until something representing a value is found, at which point it is set to "true". It's returned to "false" once the test's associated code block is located.
codegenStatus="Nothing done yet"
tokenLookahead=""

# Define a function for each type of output needed for code generation

codegenOnNewLine() {
    [[ "$codegenNewLine" == "true" ]]
}

codegenOutput() {
    echo "(codegenOutput: ${@})" >&2
    print "${@}"
    if [[ "$*" == *$'\n' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    elif [[ "$codegenNewlineLookingForSpaces" == "true" ]] && [[ "$*" == *$'    ' ]]; then
        codegenNewLine="true"
        codegenNewlineLookingForSpaces="true"
    else
        codegenNewLine="false"
    fi
}

codegenDebug() {
    echo "$codegenStatus (Debug info: Codegen: $1, routine $codegenRoutineType:$codegenRoutineName / Args: $* / States: ${stateStack[*]} / Blocks: ${blockStack[*]} / Arglist: ${codegenArgList[*]} / ($codegenNewlineLookingForSpaces/$codegenTestIndentDeferred/$testParameterFound).)" >&2
    #print_r "${blockStack[@]}" >&2
}

codegenType() {
    codegenDebug "Type" "${@}" >&2
    # First arg: type; second arg: "true" for uppercase first letter
    local result=""
    case "$targetLang" in
    "js")
        [[ "$1" == "literal-b" ]] && result='bool'
        [[ "$1" == "literal-n" ]] && result='int'
        [[ "$1" == "literal-s" ]] && result='str'
        [[ "$1" == "ident-b" ]] && result='bool'
        [[ "$1" == "ident-g" ]] && result='generic'
        [[ "$1" == "ident-n" ]] && result='int'
        [[ "$1" == "ident-s" ]] && result='str'
        [[ "$1" == "ident-ab" ]] && result='boolArray'
        [[ "$1" == "ident-an" ]] && result='intArray'
        [[ "$1" == "ident-as" ]] && result='strArray'
        [[ "$1" == "ident-ga" ]] && result='genericArray'
        [[ "$1" == "ident-gi" ]] && result='genericItems'
        [[ "$1" == "ident-r-b" ]] && result='bool'
        [[ "$1" == "ident-r-n" ]] && result='int'
        [[ "$1" == "ident-r-s" ]] && result='str'
        [[ "$1" == "ident-r-v" ]] && result='void'
        [[ "$1" == "ident-r-ab" ]] && result='boolArray'
        [[ "$1" == "ident-r-an" ]] && result='intArray'
        [[ "$1" == "ident-r-as" ]] && result='strArray'
        #[[ -z "$result" ]] && result="$1"
        [[ -z "$result" ]] && die "$1 is not a recognized type!"
        if [[ "$2" == "true" ]]; then
            codegenOutput "${result^}"
        else
            codegenOutput "$result"
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenLiteral() {
    codegenDebug "Literal" "${@}" >&2
    # First arg: type; second arg: value
    case "$targetLang" in
    "js")
        case "$1" in
        "literal-s")
            codegenOutput \'"$(asciiDecListToText "$2")"\'
            ;;
        "literal-n"|"literal-b")
            codegenOutput "$2"
            ;;
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenReference() {
    codegenDebug "Reference" "${@}" >&2
    # Reference to a variable
    # First arg: type; second arg: name
    case "$targetLang" in
    "js")
        codegenType "$1"
        codegenOutput "${2^}"
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenPrintIndentationSpaces() {
    for (( j=0; j<codegenIndent; j++ )); do
        codegenOnNewLine && codegenOutput '    '
    done
    true
}

codegenStartDocument() {
    codegenDebug "Start document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndDocument() {
    codegenDebug "End document" "${@}" >&2
    case "$targetLang" in
    "js")
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIndent() {
    codegenDebug "Indent" "${@}" >&2
    codegenOnNewLine && codegenPrintIndentationSpaces
    case "$targetLang" in
    "js")
        codegenOnNewLine || codegenOutput ' '
        codegenOutput '{'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenDedent() {
    codegenDebug "Dedent" "${@}" >&2
    #codegenIndent=$(( codegenIndent - 1 ))
    codegenPrintIndentationSpaces
    #codegenIndent=$(( codegenIndent + 1 ))
    case "$targetLang" in
    "js")
        codegenOutput '}'$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    #set +x
}

codegenComment() {
    codegenDebug "Comment" "${@}" >&2
    codegenPrintIndentationSpaces
    case "$targetLang" in
    "js")
        codegenOutput "/*""$1 */"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenArglistHasInvocation() {
    local counter="${#codegenArgList[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if  [[ "${codegenArgList[$counter]}" == ident-r-* ]]; then
            return 0
        fi
        counter=$(( counter - 1 ))
    done
    return 1
}

codegenGetCurrentRoutineType() {
    local counter="${#blockStack[@]}"
    while [[ "$counter" -ge 0 ]]; do
        if ( codegenType "${blockStack[$counter]}" &> /dev/null; ); then
            codegenOutput "${blockStack[$counter]}"
            return 0
        fi
        counter=$(( counter - 1 ))
    done
}

codegenInitializeType() {
    codegenDebug "Initialize type" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput " = "
        case "$(codegenType "$1")" in
        "bool")
            codegenOutput 'false'
            ;;
        "int")
            codegenOutput '0'
            ;;
        "str")
            codegenOutput "''"
            ;;
        "boolArray")
            codegenOutput "[]"
            ;;
        "intArray")
            codegenOutput "[]"
            ;;
        "strArray")
            codegenOutput "[]"
            ;;
        *)
            die "Initialize requested for unexpected type of $1."
        esac
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenStartArray() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput '[ '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenArrayEntryDelimiter() {
    codegenDebug "Start array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ', '
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenEndArray() {
    codegenDebug "End array" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ' ]'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenCommandInvocationStart() {
    codegenDebug "Command invocation start" "${@}" >&2
    case "$codegenRoutineName" in
    new)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when declaring a variable. Please use set to assign it after declaration."
        fi
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            codegenOutput "let "
            if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                #set -x
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                if [[ "$tokenLookahead" =~ ^(ident-|literal-) ]]; then
                    codegenOutput ' = '
                    tokenLookahead=""
                else
                    codegenInitializeType "${codegenArgList[-2]}"
                fi
                #set +x
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    return)
        if codegenArglistHasInvocation; then
            die "Sorry, invoking functions isn't available when returning. Please assign the value to a variable and return that."
        fi
        codegenOutput $'\n'
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            local returnType
            returnType="$(codegenGetCurrentRoutineType)" || true
            [[ -z "$returnType" ]] && die "Tried to return, but was not inside a routine!"
            codegenType "$returnType"
            codegenOutput "Return = "
            if [[ "${codegenArgList[-2]}" == ident-* ]]; then
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            else
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
            fi
            codegenOutput "; await assertIs"
            codegenType "$returnType" true
            codegenOutput "("
            codegenType "$returnType"
            codegenOutput "Return); "
            codegenRoutineDefinitionPreEnd
            codegenOutput "return "
            codegenType "$returnType"
            codegenOutput "Return;"$'\n'
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    if|elif|while)
        codegenPrintIndentationSpaces
        codegenOutput "$codegenRoutineName ("
        ;;
    else)
        codegenPrintIndentationSpaces
        codegenOutput "$codegenRoutineName "
        ;;
    until)
        codegenPrintIndentationSpaces
        codegenOutput "while !("
        ;;
    and|not|eq|gt|lt|add|sub|mul|div|mod|cat|die|warn|log)
        codegenPrintIndentationSpaces
        # These commands are implemented with impl* calls
        # The only purpose of using "impl" now is to prevent collisions with things that are likely to be reserved words in target languages; so, e.g. "implFIXMEUnimplemented" is unnecessary since it can just be "FIXMEUnimplemented" and be unlikely to collide.
        case "$targetLang" in
        "js")
            codegenOutput "await impl${codegenRoutineName^}("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    set)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            if [[ "${#codegenArgList[@]}" -ge 4 ]]; then
                codegenReference "${codegenArgList[-4]}" "${codegenArgList[-3]}"
                codegenOutput ' = '
                codegenLiteral "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput ";"$'\n'
            else
                # It's getting set to a command's return value
                codegenReference "${codegenArgList[-2]}" "${codegenArgList[-1]}"
                codegenOutput ' = '
                unset 'codegenArgList[-1]'
                unset 'codegenArgList[-1]'
            fi
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            codegenOutput "await $codegenRoutineName("
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationArgSeparator() {
    codegenDebug "Command invocation argument separator" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput ", "
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenCommandInvocationArglist() {
    codegenDebug "Command invocation argument list" "${@}" >&2
    case "$targetLang" in
    "js")
    #set -x
        argumentCount="${#codegenArgList[@]}"
        codegenLastKnownArglistCount="$argumentCount"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                if [[ "${codegenArgList[$k - 1]}" == literal-* ]]; then
                    codegenLiteral "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                else
                    codegenReference "${codegenArgList[$k - 1]}" "${codegenArgList[$k]}"
                fi
                if [[ "$k" != $((argumentCount - 1)) ]]; then
                    codegenCommandInvocationArgSeparator
                fi
            fi
        done
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenCommandInvocationEnd() {
    codegenDebug "Command invocation end" "${@}" >&2
    case "$codegenRoutineName" in
    return|new)
        # This shouldn't happen, because it's all handled in codegenCommandInvocationStart
        die "Internal error (this is a bug): codegenCommandInvocationEnd called for return"
        ;;
    add|eq|mod)
        # These commands are implemented with impl* calls
        case "$targetLang" in
        "js")
            codegenOutput ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    *)
        #codegenPrintIndentationSpaces
        case "$targetLang" in
        "js")
            { [[ "${blockStack[-2]}" == "command" ]] && [[ "${blockStack[-1]}" =~ ^(new|return|set)$ ]]; } || codegenOutput ")"
            ;;
        *)
            die "${FUNCNAME[0]} is not implemented in $targetLang."
            ;;
        esac
        ;;
    esac
    if ! contains "test" "${stateStack[@]}"; then
        [[ "${stateStack[-2]}" != "arglist" ]] && codegenOutput ';'$'\n'
    fi
    blockStackRemoveLast
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionStart() {
    codegenDebug "Routine definition start" "${@}" >&2
    case "$targetLang" in
    "js")
        codegenOutput "async function $codegenRoutineName("
        argumentCount="${#codegenArgList[@]}"
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenType "${codegenArgList[$k - 1]}"
                if [[ "$k" == $((argumentCount - 1)) ]]; then
                    codegenOutput "${codegenArgList[$k]^}"
                else
                    codegenOutput "${codegenArgList[$k]^}, "
                fi
            fi
        done
        codegenOutput ") {"$'\n'
        codegenIndent=$(( codegenIndent + 1 ))
        codegenPrintIndentationSpaces
        codegenIndent=$(( codegenIndent - 1 ))
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenOutput "await internalDebugCollect('"
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput " ${codegenArgList[$k]^} = ' + "
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput "${codegenArgList[$k]^} + '; '); "
            fi
        done
        codegenOutput "await internalDebugStackEnter('$codegenRoutineName:$filename');"
        if [[ "$argumentCount" != 0 ]] || [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        for (( k=0; k<argumentCount; k++ )); do
            if (( k % 2 )); then
                codegenOutput "await assertIs"
                codegenType "${codegenArgList[$k - 1]}" "true"
                codegenOutput "("
                codegenType "${codegenArgList[$k - 1]}"
                codegenOutput "${codegenArgList[$k]^});"
            fi
        done
        if [[ "$argumentCount" != 0 ]] && [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput " "
        fi
        if [[ "${blockStack[-2]}" != "ident-r-v" ]]; then
            codegenOutput "let "
            codegenType "$codegenRoutineType"
            codegenOutput "Return;"
        fi
        codegenOutput $'\n\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
    codegenRoutineType=""
    codegenRoutineName=""
    codegenArgList=()
}

codegenRoutineDefinitionPreEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    "js")
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenIndent=$(( codegenIndent + 1 ))
            codegenPrintIndentationSpaces
            codegenIndent=$(( codegenIndent - 1 ))
        fi
        codegenOutput "await internalDebugStackExit();"
        if [[ "${blockStack[-2]}" == "ident-r-v" ]]; then
            codegenOutput $'\n'
        else
            codegenOutput " "
        fi
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenRoutineDefinitionEnd() {
    codegenDebug "Routine definition end" "${@}" >&2
    case "$targetLang" in
    "js")
        # codegenOutput "}"$'\n'
        ;;
    *)
        die "${FUNCNAME[0]} is not implemented in $targetLang."
        ;;
    esac
}

codegenIsTestCommand() {
    case "$1" in
    for|if|until|while)
        true
        ;;
    *)
        false
        ;;
    esac
}

blockStackRemoveLast() {
    print_r "${blockStack[@]}" >&2
    if [[ "${blockStack[-1]}" == "" ]] && [[ "${blockStack[-2]}" == "plain-block" ]] && [[ "${blockStack[-4]}" == "test" ]]; then
        unset 'blockStack[-1]'
        unset 'blockStack[-1]'
    fi
    unset 'blockStack[-1]'
    [[ "${blockStack[-1]}" == "root" ]] && die "Internal error: Trying to remove root block!"
    unset 'blockStack[-1]'
}

#set -x
for (( i=0; i<tokenCount; i++ )); do
    if ! (( (i+1) % 3 )); then
        codegenIndent="${tokens[$i - 2]##*:}"

        #declare -p tokens >&2
        #declare -p stateStack >&2
        echo >&2
        codegenStatus="State: ${stateStack[-1]}:$codegenIndent, token #$((i / 3 + 1)) (${tokens[$i - 2]}): ${tokens[$i - 1]} ($((i-1))): ${tokens[$i]} ($i)"
        codegenDebug

        if [[ "${tokens[$i - 1]}" == "comment" ]] && [[ "${stateStack[-1]}" != "arglist" ]] && [[ "${stateStack[-1]}" != literal-a* ]]; then
            echo "(Inserting a comment)" >&2
            codegenComment "$(asciiDecListToText "${tokens[$i]}")"
        elif [[ "${tokens[$i - 1]}" == "literal-ab-start" ]]; then
            codegenStartArray "b"
            stateStack+=("literal-ab")
        elif [[ "${tokens[$i - 1]}" == "literal-ab-end" ]]; then
            codegenEndArray "b"
            unset 'stateStack[-1]'
        elif [[ "${tokens[$i - 1]}" == "literal-an-start" ]]; then
            codegenStartArray "n"
            stateStack+=("literal-an")
        elif [[ "${tokens[$i - 1]}" == "literal-an-end" ]]; then
            codegenEndArray "n"
            unset 'stateStack[-1]'
        elif [[ "${tokens[$i - 1]}" == "literal-as-start" ]]; then
            codegenStartArray "s"
            stateStack+=("literal-as")
        elif [[ "${tokens[$i - 1]}" == "literal-as-end" ]]; then
            codegenEndArray "s"
            unset 'stateStack[-1]'
        else
            case "${stateStack[-1]}" in
            literal-ab)
                case "${tokens[$i - 1]}" in
                literal-b)
                    codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayEntryDelimiter
                    ;;
                ident-b)
                    codegenReference "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-b|ident-b)$ ]] && codegenArrayEntryDelimiter
                    ;;
                newline)
                    codegenArrayEntryDelimiter
                    codegenOutput $'\n'
                    codegenPrintIndentationSpaces
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of booleans."
                    ;;
                esac
                ;;
            literal-an)
                case "${tokens[$i - 1]}" in
                literal-n)
                    codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayEntryDelimiter
                    ;;
                ident-n)
                    codegenReference "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-n|ident-n)$ ]] && codegenArrayEntryDelimiter
                    ;;
                newline)
                    codegenArrayEntryDelimiter
                    codegenOutput $'\n'
                    codegenPrintIndentationSpaces
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of numbers."
                    ;;
                esac
                ;;
            literal-as)
                case "${tokens[$i - 1]}" in
                literal-s)
                    codegenLiteral "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayEntryDelimiter
                    ;;
                ident-s)
                    codegenReference "${tokens[$i - 1]}" "${tokens[$i]}"
                    [[ "${tokens[$i + 2]}" =~ ^(literal-s|ident-s)$ ]] && codegenArrayEntryDelimiter
                    ;;
                newline)
                    codegenArrayEntryDelimiter
                    codegenOutput $'\n'
                    codegenPrintIndentationSpaces
                    ;;
                *)
                    die "Unexpected token ${tokens[$i - 1]} in array of strings."
                    ;;
                esac
                ;;
            code)
                echo "Working on code" >&2
                case "${tokens[$i - 1]}" in
                start-document)
                    codegenStartDocument
                    ;;
                end-document)
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                indent)
                    codegenIndent
                    stateStack+=("code")
                    blockStack+=("plain-block" "")
                    ;;
                dedent)
                    [[ "${blockStack[-2]}" == "ident-r-v" ]] && codegenRoutineDefinitionPreEnd # This gets generated before the return for non-void routines
                    codegenDedent
                    unset 'stateStack[-1]'
                    blockStackRemoveLast
                    ;;
                ident-r-*)
                    codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                    if [[ "${tokens[$i - 4]}" != "start-document" ]]; then
                        codegenOutput $'\n'
                    fi
                    codegenRoutineType="${tokens[$i - 1]}"
                    stateStack+=("routine-definition")
                    blockStack+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command)
                    codegenRoutineName="${tokens[$i]}"
                    case "${tokens[$i]}" in
                    if|until|while)
                        stateStack+=("test")
                        blockStack+=("test" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    new|set)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        # We need to slurp up the first token of this arglist, representing the identifier, since it's needed by codegenCommandInvocationStart. Then, codegenCommandInvocationStart gets called.
                        stateStack+=("identifier-command-argument-accumulation")
                        ;;
                    return)
                        stateStack+=("oneshot-command")
                        ;;
                    *)
                        stateStack+=("arglist")
                        blockStack+=("command" "${tokens[$i]}")
                        codegenCommandInvocationStart
                        ;;
                    esac
                    ;;
                newline)
                    #[[ "${tokens[$i - 4]}" == "newline" ]] && codegenOutput $'\n'
                    ;;
                *)
                    die "A ${tokens[$i - 1]}, ${tokens[$i]}, isn't allowed here, in ${blockStack[-2]} ${blockStack[-1]}."
                    ;;
                esac
                ;;
            oneshot-command)
                case "${tokens[$i - 1]}" in
                literal-*)
                    # Some type of data, literal.
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                *)
                    # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                    codegenCommandInvocationStart
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    ;;
                esac
                ;;
            identifier-command-argument-accumulation)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                ident-*)
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    unset 'stateStack[-1]'
                    tokenLookahead="${tokens[$i + 2]}" # should hold the next token type
                    codegenCommandInvocationStart
                    ;;
                *)
                    die "A ${blockStack[-2]} ${blockStack[-1]} wants an identifier here, not a ${tokens[$i - 1]}."
                    ;;
                esac
                ;;
            arglist|test)
                echo "Working on ${stateStack[-1]}" >&2
                case "${tokens[$i - 1]}" in
                literal-*)
                    # Some type of data, literal.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple literals (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "${tokens[$i]}")
                    ;;
                command|ident-r-*)
                    if [[ "${tokens[$i]}" =~ ^(return|new|set)$ ]] || { [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] ; }; then
                        # The arglist is ended, so drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                    else
                        if [[ "${stateStack[-1]}" != "test" ]]; then
                            codegenCommandInvocationArglist
                            if ! codegenIsTestCommand "${tokens[$i - 3]}"; then
                                [[ "$codegenLastKnownArglistCount" != 0 ]] && codegenCommandInvocationArgSeparator
                            fi
                        fi
                        codegenRoutineName="${tokens[$i]}"
                        [[ "${tokens[$i - 1]}" == ident-r-* ]] && codegenRoutineName="$(asciiDecListToText "${tokens[$i]}")"
                        codegenCommandInvocationStart
                        if [[ "${stateStack[-1]}" == "test" ]]; then
                            testParameterFound="true"
                        fi
                        stateStack+=("arglist")
                        blockStack+=("arglist-command" "${tokens[$i]}")
                    fi
                    ;;
                ident-*)
                    # Some type of data, reference.
                    [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" == "true" ]] && die "Multiple identifiers (in this case, the ${tokens[$i - 1]} \"${tokens[$i]}\") provided as parameters for a test-style construct."
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="true"
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent)
                    if [[ "$testParameterFound" == "true" ]]; then
                        [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        codegenCommandInvocationArglist
                        codegenCommandInvocationEnd
                        unset 'stateStack[-1]'
                        if [[ "$codegenTestIndentDeferred" == "indent-deferred" ]]; then
                            codegenIndent
                            codegenTestIndentDeferred="false"
                            stateStack+=("code")
                            blockStack+=("plain-block" "")
                        fi
                        i=$((i - 3))
                    fi
                    ;;
                newline)
                    if [[ "${stateStack[-1]}" != "test" ]]; then
                        # The arglist is ended, so do codegen for the command invocation, drop back and continue parsing.
                        # (This gets called multiple times for a single test, when there are multiple arglists to close for it.)
                        if [[ "${blockStack[-1]}" != "else" ]]; then
                            codegenCommandInvocationArglist
                            codegenCommandInvocationEnd
                        fi
                        unset 'stateStack[-1]'
                        i=$((i - 3))
                    fi
                    # If the test continues onto a new line, make a note that the indentation count will be offset accordingly until the end of the test is found.
                    if [[ "${stateStack[-1]}" == "test" ]] && [[ "$testParameterFound" != "true" ]]; then
                        codegenOutput $'\n'
                        codegenTestIndentDeferred="indent-deferred"
                    fi
                    ;;
                dedent|end-document|*)
                    # The arglist or test parameter is ended, so do codegen for the command invocation, drop back and continue parsing.
                    # * matches e.g. routine definitions
                    codegenCommandInvocationArglist
                    codegenCommandInvocationEnd
                    #[[ "${tokens[$i - 1]}" == "dedent" ]] || codegenIndent
                    unset 'stateStack[-1]'
                    i=$((i - 3))
                    [[ "${stateStack[-1]}" == "test" ]] && testParameterFound="false"
                    stateStack+=("code")
                    ;;
                *)
                    die "What's this token ${tokens[$i - 1]} ${tokens[$i]} doing here? does it need special handling?"
                    ;;
                esac
                ;;
            routine-definition)
                echo "Working on routine definition" >&2
                # Format: token, [ident...], code body
                # So now we look for as many types as there are. When no more types, it enters the code body of the routine. When there's a dedent, it leaves the code body of the routine.
                case "${tokens[$i - 1]}" in
                ident-*)
                    # Some type of data, reference.
                    codegenArgList+=("${tokens[$i - 1]}" "$(asciiDecListToText "${tokens[$i]}")")
                    ;;
                indent|newline)
                    # The routine definition parameter list is ended, so do codegen for the routine declaration (but not the body of it), and continue parsing.
                    codegenRoutineDefinitionStart
                    stateStack[-1]="routine-definition-end"
                    stateStack+=("code")
                    # Avoid putting in an extra code level
                    [[ "${tokens[$i - 1]}" == "newline" ]] && [[ "${tokens[$i + 2]}" == "indent" ]] && i=$((i + 3))
                    ;;
                *)
                    die "Routine definition unexpected token type"
                esac
                ;;
            routine-definition-end)
                echo "Working on routine definition end" >&2
                # Note that this is called AFTER the dedent closing brace is produced. Use codegenRoutineDefinitionPreEnd instead for things that go before the end of the routine def.
                [[ "${tokens[$i - 1]}" == "dedent" ]] && codegenDedent
                unset 'stateStack[-1]'
                codegenRoutineDefinitionEnd
                # And we'll reprocess this token now that we're done with this routine-definition.
                i=$((i - 3))
                # Don't call blockStackRemoveLast here: routine-definition-end state is entered by encountering a dedent while in code mode of the body of the routine, which will pop from the stateStack (thereby uncovering the routine-definition-end state) and take care of calling blockStackRemoveLast.
                ;;
            root)
                case "${tokens[$i - 1]}" in
                end-document)
                    codegenEndDocument
                    ;;
                *)
                    ;;
                esac
                true
                ;;
            *)
                die "Unimplemented code generation state ${stateStack[-1]}"
                ;;
            esac
        fi
    fi
done

{ [[ "${#blockStack[@]}" == "2" ]] && [[ "${blockStack[0]}" == "root" ]] && [[ "${blockStack[1]}" == "" ]]; } || die "Internal error: not all blocks were consumed, or too many blocks were consumed! This is a bug in the StageL transpiler. Remaining block stack: ${blockStack[*]}"

print_r "${stateStack[@]}" >&2
print_r "${blockStack[@]}" >&2
