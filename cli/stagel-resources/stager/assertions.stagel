#r/v/assertIsTrue b/in
#    if ne b/in true
#        assertionFailed cat bool ' is not true.'

r/v/assertIsByte n/in
    assertIsTrue intIsBetween n/in 0 255

r/v/assertIsArray ga/in
    # Just a convenience wrapper
    assertIsGenericArray ga/in

r/b/isChar s/in
    new b/res
    set b/res isCharByte byteFromChar s/in
    return b/res

r/v/assertIsChar s/in
    assertIsTrue isChar s/in

r/b/isCharByte n/in
    # Bear in mind that StageL doesn't attempt to support Unicode.
    new b/res
    set b/res intIsBetween n/in 32 126
    return b/res

r/v/assertIsCharByte n/in
    assertIsTrue isCharByte n/in

r/b/strContainsOnlyInt s/in
    # Positive int, specifically. Only digits allowed.
    new n/temp
    set n/temp len s/in
    new n/i
    set n/i 0
    new b/res
    set b/res true
    while lt n/i n/temp
        if not asciiIsDigit byteFromChar strCharAtPos s/in n/i
            set b/res false
        set n/i add n/i 1
    return b/res

r/v/assertStrContainsOnlyInt s/in
    if not strContainsOnlyInt s/in
        assertionFailed cat s/in ' does not only contain an integer.'

r/b/isNonnegative n/in
    if lt n/in 0
        return false
    return true

r/v/assertIsNonnegative n/in
    if not isNonnegative n/in
        new s/temp
        set s/temp strFrom n/in
        assertionFailed cat s/temp ' is negative.'

r/b/isDc n/in
    return isNonnegative n/in

r/v/assertIsDc n/in
    assertIsNonnegative n/in

r/b/isBase n/b
    new b/res
    set b/res intIsBetween n/b 1 36
    return b/res

r/v/assertIsBase n/b
    assertIsTrue isBase n/b

r/b/isBaseDigit s/in n/b
    assertIsChar s/in
    assertIsBase n/b
    new s/chr
    set s/chr charToUpper s/in
    new n/digitByte
    set n/digitByte byteFromChar s/in
    new b/res
    set b/res asciiIsLetterUpper n/digitByte
    set b/res or asciiIsDigit n/digitByte
    if intIsBetween n/digitByte 48 add 47 n/b
        # The base is decimal or less, and the 
        set b/res and b/res true
        return b/res
    if intIsBetween n/digitByte 
    if le n/b 10
        set b/res and b/res lt add 48 n/b # 48 = ascii 0, so e.g. 48+5=53=ascii 5, which is the first non-digit in base 5
    else
        set b/res and b/res lt add 
    set b/res and b/res b/inRange

r/v/assertIsBaseDigit s/in n/b
    assertIsChar s/in
    assertIsBase n/b
    new n/val
    set n/val 

r/v/assertIsBaseStr s/in n/b
    new n/len
    set n/len len s/in
    set n/len sub n/len 1
    new s/chr
    while ge n/len 0
        set s/chr strCharAtPos s/in n/len
        assertIsBaseChar s/chr n/b
