r/b/isDc g/in
    if not isInt g/in
        return false
    new n/num
    set n/num g/in
    new b/res
    set b/res isNonnegative n/num
    return b/res

r/b/dcIsNewline n/dc
    assertIsDc n/dc
    if eq 'b' dcGetBidiClass n/dc
        return true
    return false

r/b/dcIsSpace n/dc
    assertIsDc n/dc
    if eq 'Zs' dcGetType n/dc
        return true
    return false

r/b/dcIsPrintable n/dc
    assertIsDc n/dc
    new s/type
    set s/type dcGetType n/dc
    new s/generalType
    set s/generalType charAtPos s/type 0
    if or eq 'Zp' s/type } eq 'Zl' s/type
        return true
    return false


async function boolDcIsPrintable(dc) {
    await assertIsDc(dc); let boolReturn;

    let strType = await strDcGetType(dc);
    let strGeneralType = await strCharAtPos(strType, 0);
    switch(strType) {
        case "Zl":
        case "Zp":
            boolReturn = false; await assertIsBool(boolReturn); return boolReturn;
            break;
        default:
            break;
    }
    switch(strGeneralType) {
        case "!":
        case "C":
            boolReturn = false; await assertIsBool(boolReturn); return boolReturn;
            break;
        default:
            break;
    }
    boolReturn = true; await assertIsBool(boolReturn); return boolReturn;
}

r/an/dcarrParseDocument s/format an/Content
    assertIsByteArray an/Content
    new an/ret
    if eq s/format 'sems'
        set an/ret dcarrParseSems an/content
    else
        error cat 'Unimplemented document parsing format: ' s/format
    assertIsDcArray an/ret
    return an/ret

r/s/printableDcToChar n/dc s/targetFormat
    assertIsDc n/dc
    new s/res
    new b/temp
    set b/temp eq s/targetFormat 'ASCII-safe-subset'
    if or b/temp eq s/targetFormat 'UTF-8'
        set s/res charFromHexByte strDcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
        return s/res
    elif eq s/targetFormat 'HTML'
        set s/res strDcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
        if isBaseStr s/res 16
            set s/res charFromHexByte s/res
        else
            set s/res strDcDataLookupByValue 'mappings/to/html' 0 n/dc 1
        return s/res
    else
        die cat 'Unimplemented target format: ' s/targetFormat
    # Return an empty string if the Dc isn't printable. I don't think it should be an error probably to call this for a nonprintable Dc, although the name might imply otherwise? (possible FIXME)
    return s/res
