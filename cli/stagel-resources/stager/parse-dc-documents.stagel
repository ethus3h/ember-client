r/an/dcarrParseDocument s/format an/Content
    assertIsBytearray an/Content
    new an/ret
    if eq s/format 'sems'
        set an/ret dcarrParseSems an/content
    else
        error cat 'Unimplemented document parsing format: ' s/format
    assertIsDcarr an/ret
    return an/ret
/*

async function dcarrParseSems(bytearrayContent) {
    await assertIsBytearray(bytearrayContent); let dcarrReturn;

    // Accepts an array of bytes of a SEMS format document. Returns an array of Dcs.
    let dcarrParseResults = await newDcarr();
    let strParserState = "dc";
    let strCurrentDc = "";
    let intContentLength = await intBytearrayLength(bytearrayContent);
    for (let intByteOffset = 0; intByteOffset < await intBytearrayLength(bytearrayContent); intByteOffset++) {
        // do something with each byte in the array. bytearrayContent[intByteOffset] holds the decimal value of the given byte. These are Dcs encoded as ASCII text bytes, rather than an array of Dcs.
        switch (strParserState) {
            case "dc":
                if (await asciiIsDigit(bytearrayContent[intByteOffset])) {
                    strCurrentDc = strCurrentDc + await charFromByte(bytearrayContent[intByteOffset]);
                }
                if (await asciiIsSpace(bytearrayContent[intByteOffset])) {
                    await customTypeDcarrPush(dcarrParseResults, await intFromIntStr(strCurrentDc));
                    strCurrentDc = "";
                }
                if (bytearrayContent[intByteOffset] == 35) { // pound sign: start comment
                    strParserState = "comment";
                }
                break;
            case "comment":
                if (await asciiIsNewline(bytearrayContent[intByteOffset])) {
                    strParserState = "dc";
                }
                break;
        }
    }
    dcarrReturn = dcarrParseResults; await assertIsDcarr(dcarrReturn); return dcarrReturn;
}

// @license-end
*/
