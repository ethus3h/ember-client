r/an/byteToIntBitArray n/in
    assertIsByte n/in
    new an/res
    new s/temp
    set s/temp intToBaseStr n/in 2
    new n/len
    new n/i
    set n/len len s/temp
    new an/zero
    set an/zero ( 0 )
    while lt n/i n/len
        set an/res push an/res intFromIntStr strChar s/temp n/i
        set n/i add n/i 1
    while gt 8 count an/res
        set an/res push an/zero an/res
    assertIsIntBitArray an/res
    return an/res

r/n/byteFromIntBitArray an/in
    assertIsIntBitArray an/in
    new n/res
    new s/temp
    new n/len
    new n/i
    set n/len count an/in
    while lt n/i n/len
        set s/temp cat s/temp strFrom get an/in n/i
        set n/i add n/i 1
    set n/res intFromBaseStr s/temp 2
    assertIsByte n/res
    return n/res

r/an/byteArrayToIntBitArray an/in
    assertIsByteArray an/in
    new an/res
    new n/len
    new n/i
    set n/len count an/in
    while lt n/i n/len
        set an/res push an/res byteToIntBitArray get an/in n/i
        set n/i add n/i 1
    assertIsIntBitArray an/res
    return an/res

r/an/byteArrayFromIntBitArray an/in
    assertIsIntBitArray an/in
    new an/res
    new n/len
    new n/i
    set n/len count an/in
    new an/temp
    while le n/i n/len
        if and eq 0 mod n/i 8 } } not eq 0 count an/temp
            set an/res push an/res byteFromIntBitArray an/temp
            set an/temp ( )
        if lt n/i n/len
            set an/temp push an/temp get an/in n/i
        set n/i add n/i 1
    assertIsByteArray an/res
    return an/res

r/b/isBasenbBase n/base
    new b/res
    set b/res intIsBetween n/base 7 17

r/an/byteArrayToBasenbUtf8 an/in n/base
    assertIsByteArray an/in
    assertIsTrue isBasenbBase n/base
    new an/res
    set an/res eiteHostCall 'internalIntBitArrayToBase17bString' byteArrayToIntBitArray an/in
    # The remainder length also needs to be stored, to be able to decode successfully. We'll calculate, encode, and append it. It's always 
    new n/remainder
    set n/remainder mod 
    assertIsByteArray an/res
    return an/res

r/an/byteArrayFromBase17bUtf8 an/in
    assertIsByteArray an/in
    new an/res
    set an/res byteArrayFromIntBitArray eiteHostCall 'internalIntBitArrayFromBase17bString' an/in
    assertIsByteArray an/res
    return an/res

r/an/byteArrayToBase17bUtf8 an/in
    assertIsByteArray an/in
    new an/res
    set an/res eiteHostCall 'internalIntBitArrayToBase17bString' byteArrayToIntBitArray an/in
    # The remainder length also needs to be stored, to be able to decode successfully. We'll calculate, encode, and append it. It's always 
    new n/remainder
    set n/remainder mod 
    assertIsByteArray an/res
    return an/res

r/an/byteArrayFromBase17bUtf8 an/in
    assertIsByteArray an/in
    new an/res
    set an/res byteArrayFromIntBitArray eiteHostCall 'internalIntBitArrayFromBase17bString' an/in
    assertIsByteArray an/res
    return an/res

r/an/getArmoredUtf8EmbeddedStartUuid
    # start UUID=e82eef60-19bc-4a00-a44a-763a3445c16f
    #new an/startUuid
    #set an/startUuid ( 232 46 239 96 25 188 74 0 164 74 118 58 52 69 193 111 )
    # byteArrayToIntBitArray([ 232, 46, 239, 96, 25, 188, 74, 0, 164, 74, 118, 58, 52, 69, 193, 111 ]).then(function(v){return new TextEncoder().encode(Base16b.encode(v, 17));}).then(function(v){console.log(v.toString());})
    # UTF8 in binary: 1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,1,0,0,0,0
    new an/startUuidUtf8
    set an/startUuidUtf8 ( 244 141 129 157 244 139 182 128 243 188 183 162 243 186 128 138 243 184 165 142 244 136 186 141 243 178 139 160 244 143 186 144 )
    return an/startUuidUtf8

r/an/getArmoredUtf8EmbeddedEndUuid
    # end UUID=60bc936b-f10f-4f50-ab65-3778084060e2
    #new an/endUuid
    #set an/endUuid ( 96 188 147 107 241 15 79 80 171 101 55 120 8 64 96 226 )
    # byteArrayToIntBitArray([ 96, 188, 147, 107, 241, 15, 79, 80, 171, 101, 55, 120, 8, 64, 96, 226 ]).then(function(v){return new TextEncoder().encode(Base16b.encode(v, 17));}).then(function(v){console.log(v.toString());})
    new an/endUuidUtf8
    set an/endUuidUtf8 ( 243 188 133 185 243 180 182 175 244 136 161 186 243 191 148 138 244 134 178 166 244 141 184 130 243 178 128 176 244 143 188 157 )
    return an/endUuidUtf8

#r/an/byteArrayToArmoredBase17bUtf8 an/in
#    assertIsByteArray an/in
#    new an/res
#    set an/res getArmoredBase17bUtf8StartUuid
#    set an/res append an/res eiteHostCall 'internalIntBitArrayToBase17bString' byteArrayToIntBitArray an/in
#    assertIsByteArray an/res
#    set an/res append an/res getArmoredBase17bUtf8EndUuid
#    return an/res

#r/an/byteArrayFromArmoredBase17bUtf8 an/in
#    assertIsByteArray an/in
#    new an/temp
#    set an/temp getArmoredBase17bUtf8StartUuid
#    assertIsTrue eq an/temp anSubset an/in 0 count an/temp
#    set an/temp getArmoredBase17bUtf8EndUuid
#    assertIsTrue eq an/temp anSubset an/in -1 sub -1 count an/temp
#    new an/res
#    set an/res eiteHostCall 'internalIntBitArrayFromBase17bString' an/in
#    assertIsByteArray an/res
#    return an/res
