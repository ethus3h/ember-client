r/an/dcaToUtf8 an/content
    assertIsDcArray an/content
    new an/res
    new n/l
    set n/l count an/content
    new n/c
    set n/c 0
    new an/temp
    new n/dcAtIndex
    new an/unmappables
    new n/unmappablesCount
    new n/unmappablesCounter
    new n/currentUnmappable
    new an/unmappablesIntermediatePacked
    new as/variantSettings
    set as/variantSettings utf8VariantSettings 'out'
    new b/dcBasenbEnabled
    set b/dcBasenbEnabled contains as/variantSettings 'dcBasenb'
    while lt n/c n/l
        set n/dcAtIndex get an/content n/c
        set an/temp dcToFormat 'utf8' n/dcAtIndex
        if eq 0 count an/temp
            if dcBasenbEnabled
                set an/unmappables push an/unmappables n/dcAtIndex
            else
                exportWarningUnmappable n/c n/dcAtIndex
        else
            if dcBasenbEnabled
                set n/unmappablesCount count an/unmappables
                if gt 0 n/unmappablesCount
                    # We've gotten to the end of a string of unmappable characters, so convert them to PUA characters
                    set n/unmappablesCounter 0
                    while lt n/unmappablesCounter n/unmappablesCount
                        # The packing method for this works basically like UTF8, where each character is mapped to a series of bytes. So, first  get the bytearray for the character we're on.
                        set n/currentUnmappable get an/unmappables n/unmappablesCounter
                        set n/unmappablesCounter add n/unmappablesCounter 1
                    set an/unmappables ( )
        set an/res append an/res an/temp
        set n/c add n/c 1
    assertIsByteArray an/res
    return an/res

r/an/dcaFromUtf8 an/content
    new an/res
    new an/remaining
    set an/remaining an/content
    new an/temp
    while not eq 0 count an/remaining
        set an/temp ( )
        set an/temp push an/temp firstCharOfUtf8String an/remaining
        set an/res push an/res dcFromFormat 'unicode' an/temp
        set an/remaining anSubset an/remaining count an/temp } -1
    return an/res

r/as/utf8VariantSettings s/direction
    new as/res
    new s/enabledVariants
    set s/enabledVariants getSettingForFormat 'utf8' s/direction 'variants'
    # TODO: Support multiple variants enabled (chop up the value of the s/enabledVariants string into its constituent variants)
    set as/res push as/res s/enabledVariants
    return as/res

r/an/dcaToDcbnbUtf8 an/content
    # convenience wrapper
    new an/res
    pushImportSettings getFormatId 'utf8' } 'variants:dcBasenb,'
    set an/res dcaToUtf8 an/content
    popImportSettings getFormatId 'utf8'
    return an/res

r/an/dcaFromDcbnbUtf8 an/content
    # convenience wrapper
    new an/res
    pushImportSettings getFormatId 'utf8' } 'variants:dcBasenb,'
    set an/res dcaFromUtf8 an/content
    popImportSettings getFormatId 'utf8'
    return an/res
