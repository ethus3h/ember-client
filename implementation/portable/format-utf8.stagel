r/an/dcaToUtf8 an/content
    assertIsDcArray an/content
    new an/res
    new n/l
    set n/l count an/content
    new n/c
    set n/c 0
    new an/temp
    new n/dcAtIndex
    new an/unmappables
    new n/unmappablesCount
    new n/unmappablesCounter
    new an/unmappablesIntermediatePacked
    new b/foundAnyUnmappables
    set b/foundAnyUnmappables false
    new as/variantSettings
    set as/variantSettings utf8VariantSettings 'out'
    new b/dcBasenbEnabled
    set b/dcBasenbEnabled contains as/variantSettings 'dcBasenb'
    while le n/c n/l
        # Start by getting the character's UTF8 equivalent and putting it in an/temp. This might be empty, if the character can't be mapped to UTF8.
        if lt n/c n/l
            set n/dcAtIndex get an/content n/c
            set an/temp dcToFormat 'utf8' n/dcAtIndex
        # Could the character be mapped? If not, stick it in the unmappables array or warn as appropriate.
        if eq 0 count an/temp
            if lt n/c n/l
                if b/dcBasenbEnabled
                    set an/unmappables push an/unmappables n/dcAtIndex
                else
                    exportWarningUnmappable n/c n/dcAtIndex
        # If we've reached the end of the input string or the last character was mappable, convert the an/unmappables array to PUA characters and append that result to the output string
        if b/dcBasenbEnabled
            if or eq n/c n/l } ne 0 count an/temp
                set n/unmappablesCount count an/unmappables
                if ne 0 n/unmappablesCount
                    if not b/foundAnyUnmappables
                        set an/res append an/res getArmoredUtf8EmbeddedStartUuid
                    set b/foundAnyUnmappables true
                    # We've gotten to the end of a string of unmappable characters, so convert them to PUA characters
                    set n/unmappablesCounter 0
                    while lt n/unmappablesCounter n/unmappablesCount
                        # The packing method for this works basically like UTF8, where each character is mapped to a series of bytes. So, first  get the bytearray for the character we're on.
                        set an/unmappablesIntermediatePacked append an/unmappablesIntermediatePacked pack32 get an/unmappables n/unmappablesCounter
                        set n/unmappablesCounter add n/unmappablesCounter 1
                    set an/res append an/res byteArrayToBase17bUtf8 an/unmappablesIntermediatePacked
                    set an/unmappables ( )
                    set an/unmappablesIntermediatePacked ( )
        # Stick the current character onto the result array
        if lt n/c n/l
            set an/res append an/res an/temp
        # and finally increment the loop counter
        set n/c add n/c 1
    if and b/dcBasenbEnabled b/foundAnyUnmappables
        set an/res append an/res getArmoredUtf8EmbeddedEndUuid
    assertIsByteArray an/res
    return an/res

r/an/dcaFromUtf8 an/content
    new an/res
    new an/remaining
    set an/remaining an/content
    new an/temp
    new an/latestChar
    new n/dcBasenbUuidMonitorState
    set n/dcBasenbUuidMonitorState 0
    new n/dcBasenbUuidMonitorReprocessNeededCount
    set n/dcBasenbUuidMonitorReprocessNeededCount 0
    new as/variantSettings
    set as/variantSettings utf8VariantSettings 'in'
    new b/dcBasenbEnabled
    set b/dcBasenbEnabled contains as/variantSettings 'dcBasenb'
    new b/inDcBasenbSection
    set b/inDcBasenbSection false
    new b/skipNextChar
    set b/skipNextChar false
    new an/collectedDcBasenbChars
    new n/collectedDcBasenbCharsCount
    new n/collectedDcBasenbCharsCounter
    new an/currentUnmappableChar
    new n/tempArrayCount
    while not eq 0 count an/remaining
        set an/temp ( )
        set an/latestChar pack32 firstCharOfUtf8String an/remaining
        if b/dcBasenbEnabled
            if not b/inDcBasenbSection
                # 8 characters for uuid. Probably a better way to do this but oh well. Got them with new TextEncoder().encode('[char]'); etc.
                if ne 0 n/dcBasenbUuidMonitorReprocessNeededCount
                    set n/dcBasenbUuidMonitorReprocessNeededCount sub n/dcBasenbUuidMonitorReprocessNeededCount 1
                else
                    if eq n/dcBasenbUuidMonitorState 0
                        if arrEq an/latestChar ( 244 141 129 157 )
                            set n/dcBasenbUuidMonitorState 1
                    elif eq n/dcBasenbUuidMonitorState 1
                        if arrEq an/latestChar ( 244 139 182 128 )
                            set n/dcBasenbUuidMonitorState 2
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 2
                        if arrEq an/latestChar ( 243 188 183 162 )
                            set n/dcBasenbUuidMonitorState 3
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 3
                        if arrEq an/latestChar ( 243 186 128 138 )
                            set n/dcBasenbUuidMonitorState 4
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 4
                        if arrEq an/latestChar ( 243 184 165 142 )
                            set n/dcBasenbUuidMonitorState 5
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 5
                        if arrEq an/latestChar ( 244 136 186 141 )
                            set n/dcBasenbUuidMonitorState 6
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 6
                        if arrEq an/latestChar ( 243 178 139 160 )
                            set n/dcBasenbUuidMonitorState 7
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 7
                        if arrEq an/latestChar ( 244 143 186 144 )
                            set n/dcBasenbUuidMonitorState 0
                            set b/inDcBasenbSection true
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    if ne 0 n/dcBasenbUuidMonitorReprocessNeededCount
                        # It's necessary to reprocess the number of bytes that were consumed while checking for a UUID
                        set n/tempArrayCount sub count an/content } count an/remaining
                        set an/remaining anSubset an/content n/tempArrayCount add n/tempArrayCount mul 4 n/dcBasenbUuidMonitorReprocessNeededCount
            else
                if ne 0 n/dcBasenbUuidMonitorReprocessNeededCount
                    set n/dcBasenbUuidMonitorReprocessNeededCount sub n/dcBasenbUuidMonitorReprocessNeededCount 1
                else
                    if eq n/dcBasenbUuidMonitorState 0
                        if arrEq an/latestChar ( 243 188 133 185 )
                            set n/dcBasenbUuidMonitorState 1
                    elif eq n/dcBasenbUuidMonitorState 1
                        if arrEq an/latestChar ( 243 180 182 175 )
                            set n/dcBasenbUuidMonitorState 2
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 2
                        if arrEq an/latestChar ( 244 136 161 186 )
                            set n/dcBasenbUuidMonitorState 3
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 3
                        if arrEq an/latestChar ( 243 191 148 138 )
                            set n/dcBasenbUuidMonitorState 4
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 4
                        if arrEq an/latestChar ( 244 134 178 166 )
                            set n/dcBasenbUuidMonitorState 5
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 5
                        if arrEq an/latestChar ( 244 141 184 130 )
                            set n/dcBasenbUuidMonitorState 6
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 6
                        if arrEq an/latestChar ( 243 178 128 176 )
                            set n/dcBasenbUuidMonitorState 7
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    elif eq n/dcBasenbUuidMonitorState 7
                        if arrEq an/latestChar ( 244 143 188 157 )
                            set n/dcBasenbUuidMonitorState 0
                            set b/inDcBasenbSection false
                        else
                            set n/dcBasenbUuidMonitorReprocessNeededCount n/dcBasenbUuidMonitorState
                            set n/dcBasenbUuidMonitorState 0
                    if ne 0 n/dcBasenbUuidMonitorReprocessNeededCount
                        # It's necessary to reprocess the number of bytes that were consumed while checking for a UUID
                        set n/tempArrayCount count an/remaining
                        set an/remaining anSubset an/content n/tempArrayCount add n/tempArrayCount mul 4 n/dcBasenbUuidMonitorReprocessNeededCount
                if eq 0 n/dcBasenbUuidMonitorState
                    # Check for basenb characters and collect them for decoding
                    if isBasenbChar an/latestChar
                        set an/collectedDcBasenbChars append an/collectedDcBasenbChars an/latestChar
                        set b/skipNextChar true
                    else
                        # Not a basenb char, so decode the ones we've collected
                        set an/collectedDcBasenbChars byteArrayFromBase17bUtf8 an/collectedDcBasenbChars
                        set n/collectedDcBasenbCharsCount count an/collectedDcBasenbChars
                        set n/collectedDcBasenbCharsCounter 0
                        while lt n/collectedDcBasenbCharsCount n/collectedDcBasenbCharsCounter
                            set an/currentUnmappableChar pack32 firstCharOfUtf8String
                            set an/res append an/res unpack32 an/currentUnmappableChar
                            set n/collectedDcBasenbCharsCounter add n/collectedDcBasenbCharsCounter count an/currentUnmappableChar
                        set an/collectedDcBasenbChars ( )
        if eq 0 n/dcBasenbUuidMonitorState
            if b/skipNextChar
                set b/skipNextChar false
            else
                set an/temp an/latestChar
                new an/tempFromUnicode
                set an/tempFromUnicode dcFromFormat 'unicode' an/temp
                if ne -1 get an/tempFromUnicode 0
                    set an/res append an/res an/tempFromUnicode
        set an/remaining anSubset an/remaining count an/latestChar } -1
    if b/dcBasenbEnabled
        # Handle any remaining collected DcBasenb characters
        set an/collectedDcBasenbChars byteArrayFromBase17bUtf8 an/collectedDcBasenbChars
        set n/collectedDcBasenbCharsCount count an/collectedDcBasenbChars
        set n/collectedDcBasenbCharsCounter 0
        while lt n/collectedDcBasenbCharsCount n/collectedDcBasenbCharsCounter
            set an/currentUnmappableChar pack32 firstCharOfUtf8String
            set an/res append an/res unpack32 an/currentUnmappableChar
            set n/collectedDcBasenbCharsCounter add n/collectedDcBasenbCharsCounter count an/currentUnmappableChar
    return an/res

r/as/utf8VariantSettings s/direction
    new as/res
    new s/enabledVariants
    set s/enabledVariants getSettingForFormat 'utf8' s/direction 'variants'
    # TODO: Support multiple variants enabled (chop up the value of the s/enabledVariants string into its constituent variants)
    set as/res push as/res s/enabledVariants
    return as/res

r/an/dcaToDcbnbUtf8 an/content
    # convenience wrapper
    new an/res
    pushExportSettings getFormatId 'utf8' } 'variants:dcBasenb,'
    set an/res dcaToUtf8 an/content
    popExportSettings getFormatId 'utf8'
    return an/res

r/an/dcaFromDcbnbUtf8 an/content
    # convenience wrapper
    new an/res
    pushImportSettings getFormatId 'utf8' } 'variants:dcBasenb,'
    set an/res dcaFromUtf8 an/content
    popImportSettings getFormatId 'utf8'
    return an/res
