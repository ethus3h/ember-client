r/ga/subset ga/in n/start n/end
    new n/count
    set n/count count ga/in
    new n/i
    set n/i n/start
    if lt n/end 0
        set n/end add n/count n/end
    set n/count n/end
    new ga/res
    while lt n/i n/count
        set ga/res push ga/res 
        set g/elem get ga/in n/count
        if eq g/elem g/value
            return true
        set n/count sub n/count 1
    return false

r/b/contains ga/in g/value
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if eq g/elem g/value
            return true
        set n/count sub n/count 1
    return false

r/b/isArray gi/in
    # Just a convenience wrapper
    new b/res
    set b/res isGenericArray gi/in
    return b/res

r/b/isIntArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isInt g/elem
            return false
        set n/count sub n/count 1
    return true

r/b/isStrArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isStr g/elem
            return false
        set n/count sub n/count 1
    return true

r/b/isBoolArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isBool g/elem
            return false
        set n/count sub n/count 1
    return true

r/b/isCharArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isChar g/elem
            return false
        set n/count sub n/count 1
    return true

r/b/isByteArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isByte g/elem
            return false
        set n/count sub n/count 1
    return true

r/b/isDcArray ga/in
    new n/count
    set n/count sub count ga/in } 1
    new g/elem
    while ge n/count 0
        set g/elem get ga/in n/count
        if not isDc g/elem
            return false
        set n/count sub n/count 1
    return true

r/n/sumArray an/in
    new n/count
    set n/count sub count ga/in } 1
    new n/res
    while ge n/count 0
        set n/res add n/res get an/in n/count
        set n/count sub n/count 1
    return n/res
