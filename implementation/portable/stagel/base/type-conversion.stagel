r/s/strPrintArr ga/input
    # The reverse of this for an/ input is intArrFromStrPrintedArr.
    # Hint: running this on a DcArray produces a sems document that can be turned back into a DcArray with dcarrParseSems strToByteArray s/str :)
    new n/count
    set n/count count ga/input
    new n/i
    set n/i 0
    new s/out
    while lt n/i n/count
        set s/out cat s/out strFrom get ga/input n/i
        set s/out cat s/out ' '
        set n/i add n/i 1
    return s/out

r/s/printArray ga/in
    # Just a convenience wrapper
    new s/res
    set s/res strPrintArr ga/in
    return s/res

r/s/strPrintArray ga/in
    # Just a convenience wrapper
    new s/res
    set s/res strPrintArr ga/in
    return s/res

r/s/printArr ga/in
    # Just a convenience wrapper
    new s/res
    set s/res strPrintArr ga/in
    return s/res

r/as/strSplit s/in s/separator
    new as/res
    new n/separLen
    set n/separLen len s/separator
    new s/remaining
    set s/remaining s/in
    new n/remainingLen
    set n/remainingLen len s/remaining
    new s/currentElem
    new s/currentChar
    while lt 0 n/remainingLen
        if eq s/separator substr s/remaining 0 n/separLen
            set as/res push as/res s/currentElem
            set s/currentElem ''
            set s/remaining substr s/remaining n/separLen -1
        else
            set s/currentChar strChar s/remaining 0
            set s/currentElem cat s/currentElem s/currentChar
            if gt 1 n/remainingLen
                set s/remaining substr s/remaining 2 -1
            else
                set s/remaining ''
        set n/remainingLen len s/remaining
    if ne '' s/currentElem
        # No trailing delimiter
        set as/res push as/res s/currentElem
    return as/res

r/s/strJoin ga/in s/separator
    # The reverse of this for an/ input is intArrFromStrPrintedArr.
    # Hint: running this on a DcArray produces a sems document that can be turned back into a DcArray with dcarrParseSems strToByteArray s/str :)
    new n/count
    set n/count count ga/input
    new n/i
    set n/i 0
    new s/out
    while lt n/i n/count
        set s/out cat s/out strFrom get ga/input n/i
        set s/out cat s/out ' '
        set n/i add n/i 1
    return s/out

r/an/intArrFromStrPrintedArr s/input
    # Reverse of strPrintArr with an an/ parameter.
    new an/res
    new an/content
    set an/content strToByteArray s/input
    new s/currentInt
    set s/currentInt ''
    new n/contentLength
    set n/contentLength count an/content
    new n/byteOffset
    new n/currentByte
    while lt n/byteOffset n/contentLength
        # do something with each byte in the array. an/content[n/byteOffset] holds the decimal value of the given byte. These are ints represented as ASCII text bytes, rather than an array of ints.
        set n/currentByte get an/content n/byteOffset
        if asciiIsDigit n/currentByte
            set s/currentInt cat s/currentInt charFromByte n/currentByte
        elif asciiIsSpace n/currentByte
            set an/res push an/res intFromIntStr s/currentInt
            set s/currentInt ''
        else
            die 'Unexpected parser state in intArrFromStrPrintedArr.'
        set n/byteOffset add n/byteOffset 1
    if ne 0 len s/currentInt
        # Ended without a trailing space
        set an/res push an/res intFromIntStr s/currentInt
    return an/res

r/s/charFromHexByte s/hexByte
    # Bear in mind that StageL doesn't attempt to support Unicode.
    assertIsBaseStr s/hexByte 16
    new s/res
    set s/res charFromByte intFromBaseStr s/hexByte 16
    return s/res

r/an/strToByteArray s/input
    new n/count
    set n/count len s/input
    new n/i
    set n/i 0
    new an/out
    while lt n/i n/count
        set an/out push an/out byteFromChar strChar s/input n/i
        set n/i add n/i 1
    return an/out

r/s/strFromByteArray an/input
    # Remember this will break if there are non-string bytes in it.
    new n/count
    set n/count count an/input
    new n/i
    set n/i 0
    new s/out
    while lt n/i n/count
        set s/out cat s/out charFromByte get an/input n/i
        set n/i add n/i 1
    return s/out
