r/n/prepareDocumentExec an/contents
    new n/execId
    set n/execId -1
    # documentExecData is a global, created during initialization. It holds the current document state for any documents being executed.
    set n/execId count as/documentExecPtrs
    set as/documentExecData push as/documentExecData strPrintArr an/contents
    # documentExecPtrs is also a global created during init; it holds the current execution state of each document as an array of strings of of comma-terminated ints with the last indicating the position in the document where execution is (the earlier ints represent where execution should return to upon exiting the current scope, so it acts as a stack).
    set as/documentExecSymbolIndex push as/documentExecSymbolIndex ''
    set as/documentExecPtrs push as/documentExecPtrs '0,'
    set as/documentExecFrames push as/documentExecFrames ''
    set as/documentExecEvents push as/documentExecEvents ''
    assertIsExecId n/execId
    return n/execId

r/b/isExecId n/execId
    if lt n/execId count as/documentExecPtrs
        return true
    return false

r/n/getCurrentExecPtrPos n/execId
    new n/res
    set n/res intFromIntStr get strSplit get as/documentExecPtrs n/execId } ',' } -1
    return n/res

r/n/getNextExecPtrPos n/execId
    new n/res
    set n/res intFromIntStr get strSplit get as/documentExecPtrs n/execId } ',' } -2
    return n/res

r/an/getCurrentExecData n/execId
    new an/res
    set an/res intArrFromStrPrintedArr get as/documentExecData n/execId
    return an/res

r/an/getCurrentExecFrame n/execId
    new an/res
    set an/res intArrFromStrPrintedArr get as/documentExecFrames n/execId
    return an/res

r/v/startDocumentExec n/execId
    assertIsExecId n/execId
    new b/continue
    set b/continue true
    new n/currentPtrPos
    new an/wipFrame
    new n/dc
    new an/documentWorkingCopyData
    set an/documentWorkingCopyData intArrFromStrPrintedArr get as/documentExecData n/execId
    new as/state
    set as/state [ 'normal' ]
    new b/lastCharacterWasEscape
    set b/lastCharacterWasEscape false
    while b/continue
        # This loop goes through each Dc in the document, running it.
        # Where are we in the document? Store it in n/currentPtrPos.
        set n/currentPtrPos getCurrentExecPtrPos n/execId
        # The execution process basically is a big state machine.
        if gt 0 n/currentPtrPos
            # Pointer's been set to a negative position, so we're done with the document
            set b/continue false
        else
            set n/dc get an/documentWorkingCopyData n/currentPtrPos
            if b/lastCharacterWasEscape
                set b/lastCharacterWasEscape false
                set n/currentPtrPos add 1 n/currentPtrPos
            else
                if eq n/dc 255
                    set b/lastCharacterWasEscape true
                    set n/currentPtrPos add 1 n/currentPtrPos
                else
                    if eq 'normal' last as/state
                        if in n/dc ( 246 247 )
                            set as/state push as/state 'single-line source comment'
                        elif in n/dc ( 249 250 )
                            set as/state push as/state 'block source comment'
                        if dcIsELCode n/dc
                            # FIXME unimplemented
                        else
                            # Normal Dc
                            set an/wipFrame push an/wipFrame n/dc
                    elif eq 'single-line source comment' last as/state
                        if eq n/dc 248
                            set as/state pop as/state
                    elif eq 'block source comment' last as/state
                        if eq n/dc 251
                            set as/state pop as/state
                    set n/currentPtrPos add 1 n/currentPtrPos
        # FIXME Just copy the input document over for now
        set an/wipFrame intArrFromStrPrintedArr get as/documentExecData n/execId
        set b/continue false
        # Frame is done, so convert it to the environment-appropriate format and output it
        setElement as/documentExecFrames n/execId printArr an/wipFrame
        set an/wipFrame ( )
        renderDrawContents dcaToFormat getEnvPreferredFormat } getCurrentExecFrame n/execId
