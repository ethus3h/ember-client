r/n/prepareDocumentExec an/contents
    new n/execId
    set n/execId -1
    # documentExecData is a global, created during initialization. It holds the current document state for any documents being executed.
    set n/execId count as/documentExecPtrs
    set as/documentExecData push as/documentExecData strPrintArr an/contents
    # documentExecPtrs is also a global created during init; it holds the current execution state of each document as an array of strings of of comma-terminated ints with the last indicating the position in the document where execution is (the earlier ints represent where execution should return to upon exiting the current scope, so it acts as a stack).
    set as/documentExecSymbolIndex push as/documentExecSymbolIndex ''
    set as/documentExecPtrs push as/documentExecPtrs '0,'
    set as/documentExecFrames push as/documentExecFrames ''
    set as/documentExecEvents push as/documentExecEvents ''
    assertIsExecId n/execId
    return n/execId

r/b/isExecId n/execId
    if lt n/execId count as/documentExecPtrs
        return true
    return false

r/n/getCurrentExecPtrPos n/execId
    new n/res
    set n/res intFromIntStr get strSplit get as/documentExecPtrs n/execId } ',' } -1
    return n/res

r/n/getNextExecPtrPos n/execId
    new n/res
    set n/res intFromIntStr get strSplit get as/documentExecPtrs n/execId } ',' } -2
    return n/res

r/an/getCurrentExecData n/execId
    new an/res
    set an/res intArrFromStrPrintedArr get as/documentExecData n/execId
    return an/res

r/an/getCurrentExecFrame n/execId
    new an/res
    set an/res intArrFromStrPrintedArr get as/documentExecFrames n/execId
    return an/res

r/v/startDocumentExec n/execId
    assertIsExecId n/execId
    new b/continue
    set b/continue true
    new n/currentPtrPos
    new an/wipFrame
    new n/dc
    new an/documentWorkingCopyData
    set an/documentWorkingCopyData intArrFromStrPrintedArr get as/documentExecData n/execId
    new s/state
    set s/state 'normal'
    while b/continue
        # This loop goes through each Dc in the document, running it.
        # Where are we in the document? Store it in n/currentPtrPos.
        set n/currentPtrPos getCurrentExecPtrPos n/execId
        if gt 0 n/currentPtrPos
            # Pointer's been set to a negative position, so we're done with the document
            set b/continue false
        else
            # The execution process basically is a big state machine.
            set n/dc get an/documentWorkingCopyData n/currentPtrPos
            if eq n/dc
            if dcIsELCode n/dc
                
            elif eq n/dc 
            else
                # Normal Dc
                set an/wipFrame push an/wipFrame n/dc
        # FIXME Just copy the input document over for now
        set an/wipFrame intArrFromStrPrintedArr get as/documentExecData n/execId
        set b/continue false
        # Frame is done, so convert it to the environment-appropriate format and output it
        setElement as/documentExecFrames n/execId printArr an/wipFrame
        set an/wipFrame ( )
        renderDrawContents dcaToFormat getEnvPreferredFormat } getCurrentExecFrame n/execId
