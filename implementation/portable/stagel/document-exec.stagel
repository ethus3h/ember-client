r/n/prepareDocumentExec an/contents
    new n/execId
    set n/execId -1
    # documentExecData is a global, created during initialization. It holds the current document state for any documents being executed.
    set n/execId count an/documentExecPtrs
    set as/documentExecData push as/documentExecData strPrintArr an/contents
    # documentExecPtrs is also a global created during init; it holds the current execution state of each document as a list of comma-prefixed ints with the last indicating the position in the document where execution is (the earlier ints represent where execution should return to upon exiting the current scope, so it acts as a stack).
    set as/documentExecSymbolIndex push as/documentExecSymbolIndex ''
    set as/documentExecPtrs push as/documentExecPtrs ',0'
    set as/documentExecFrames push as/documentExecFrames ''
    set as/documentExecEvents push as/documentExecEvents ''
    assertIsExecId n/execId
    return n/execId

r/b/isExecId n/execId
    if lt n/execId count an/documentExecPtrs
        return true
    return false

r/n/startDocumentExec n/execId
    assertIsExecId n/execId
    new b/continue
    set b/continue true
    new n/currentPtrPos
    # for now
    set b/continue false
    while b/continue
        set n/currentPtrPos getCurrentExecPtrPos n/execId
        if gt 0 n/currentPtrPos
            # Pointer's been set to a negative position, so we're done with the document
            set b/continue false
    # Just copy it over for now
    setElement as/documentExecFrames n/execId get as/documentExecData n/execId
