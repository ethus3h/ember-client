r/n/bytesToInt32 n/a n/b n/c n/d
    # Input bytes are 0 to 255
    new n/res
    # 8 least significant bits
    set n/res n/d
    # next 8
    set n/res add n/res mul n/c 255
    # and so on
    set n/res add n/res mul n/b 65535
    if gt n/a 127
        new n/temp
        set n/temp sub n/a 127
        
    set n/res 
    #include <stdio.h>


void printBits(unsigned int num){
    unsigned int size = sizeof(unsigned int);
    unsigned int maxPow = 1<<(size*8-1);
    printf("MAX POW : %u\n",maxPow);
    int i=0,j;for(;i<size*8;++i){
    // print last bit and shift left.
    printf("%u ",num&maxPow ? 1 : 0);
    num = num<<1;
}
}
int main() {
  unsigned char a;
  a=255;
  unsigned long res;
  res=a;
res=res * 65535 * 8;
res=res + a;
  printf("a=%d\n", a);
  printf("res=%d\n", res);
  printBits(res);
  return 0;
}

    return n/res

r/n/bitAnd32 n/a n/b
    new n/res
    set n/res 
    return n/res

r/n/bitAnd n/width n/byte1 n/byte2
    new n/res
    if eq n/width 8
        set n/res bitAnd8 n/byte1 n/byte2
    elif eq n/width 32
        set n/res bitAnd32 n/byte1 n/byte2
    else
        die cat 'bitAnd called with unsupported bit width ' strFrom n/width
    return n/res

r/n/bitNot n/width n/byte
    new n/res
    if eq n/width 8
        set n/res bitNot8 n/byte
    elif eq n/width 32
        set n/res bitNot32 n/byte
    else
        die cat 'bitNot called with unsupported bit width ' strFrom n/width
    return n/res

r/n/bitLshift n/width n/byte1 n/places
    new n/res
    if eq n/width 8
        set n/res bitLshift8 n/byte
    elif eq n/width 32
        set n/res bitLshift32 n/byte
    else
        die cat 'bitLshift called with unsupported bit width ' strFrom n/width
    return n/res

r/n/bitRshift n/width n/byte1 n/places
    new n/res
    if eq n/width 8
        set n/res bitRshift8 n/byte
    elif eq n/width 32
        set n/res bitRshift32 n/byte
    else
        die cat 'bitRshift called with unsupported bit width ' strFrom n/width
    return n/res

r/n/bitOr n/width n/byte1 n/byte2
    assertIsByte n/byte1
    assertIsByte n/byte2
    new n/temp
    set n/temp bitNot n/width n/byte1
    set n/temp bitNot n/width bitAnd n/width n/temp bitNot8 n/byte2
    assertIsByte n/temp
    return n/temp

r/n/bitNor n/width n/byte1 n/byte2
    assertIsByte n/byte1
    assertIsByte n/byte2
    new n/temp
    set n/temp bitNot n/width bitOr n/width n/byte1 n/byte2
    assertIsByte n/temp
    return n/temp

r/n/bitNand n/width n/byte1 n/byte2
    assertIsByte n/byte1
    assertIsByte n/byte2
    new n/temp
    set n/temp bitNot n/width bitAnd n/width n/byte1 n/byte2
    assertIsByte n/temp
    return n/temp

r/n/bitXor n/width n/byte1 n/byte2
    assertIsByte n/byte1
    assertIsByte n/byte2
    new n/temp
    set n/temp bitNand n/width n/byte1 n/byte2
    set n/temp bitAnd n/width n/temp bitOr n/width n/byte1 n/byte2
    assertIsByte n/temp
    return n/temp

r/n/bitXnor n/width n/byte1 n/byte2
    assertIsByte n/byte1
    assertIsByte n/byte2
    new n/temp
    set n/temp bitNot n/width bitXor n/width n/byte1 n/byte2
    assertIsByte n/temp
    return n/temp
