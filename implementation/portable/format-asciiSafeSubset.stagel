r/an/dcaFromAsciiSafeSubset an/content
    new n/len
    set n/len count an/content
    new n/counter
    set n/counter 0
    new s/state
    set s/state 'normal'
    new an/prefilter
    new n/currentChar
    while lt n/counter n/len
        set n/currentChar get an/content n/counter
        assertIsTrue isAsciiSafeSubsetChar n/currentChar
        if and eq s/state 'normal' } eq n/currentChar 13
            # Wait to see if there's a lf after this cr. If so, treat them as a unit.
            set s/state 'crlf'
        elif eq s/state 'crlf'
            set s/state 'normal'
            set an/prefilter append an/prefilter ( 13 10 )
            if ne n/currentChar 10
                # Reparse the current character
                set n/counter sub n/counter 1
        set n/counter add n/counter 1

r/b/isAsciiSafeSubsetChar n/char
    new b/res
    set b/res or asciiIsPrintable n/char } or asciiIsNewline n/char
    return b/res
