r/an/dcaFromAsciiSafeSubset an/content
    new n/len
    set n/len count an/content
    new n/counter
    set n/counter 0
    new s/state
    set s/state 'normal'
    new an/prefilter
    new n/currentChar
    new b/strict
    set b/strict false
    if eq 'true' getSettingForFormat 'asciiSafeSubset' 'in' 'strict'
        set b/strict true
    while lt n/counter n/len
        set n/currentChar get an/content n/counter
        assertIsTrue isAsciiSafeSubsetChar n/currentChar
        if and b/strict and eq s/state 'normal' } eq n/currentChar 10
            die 'LF without preceding CR not allowed in asciiSafeSubset strict mode.'
        if and eq s/state 'normal' } eq n/currentChar 13
            # Wait to see if there's a lf after this cr. If so, treat them as a unit.
            set s/state 'crlf'
        elif eq s/state 'crlf'
            set s/state 'normal'
            set an/prefilter append an/prefilter crlf
            if ne n/currentChar 10
                # Reparse the current character
                set n/counter sub n/counter 1
        else
            set an/prefilter push an/prefilter n/currentChar
        set n/counter add n/counter 1

r/b/isAsciiSafeSubsetChar n/char
    new b/res
    set b/res or asciiIsPrintable n/char } or asciiIsNewline n/char
    return b/res
