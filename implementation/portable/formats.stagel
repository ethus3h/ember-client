r/an/dcaFromFormat s/inFormat an/contentBytes
    assertIsSupportedInputFormat s/inFormat
    assertIsByteArray an/contentBytes
    new an/ret
    if or eq s/inFormat 'sems' } eq s/inFormat 'integerList'
        # TODO: The sems parser can handle integerList format too, but perhaps a dedicated parser should be provided so it isn't too permissive.
        set an/ret dcaFromSems an/contentBytes
    elif eq s/inFormat 'ascii'
        set an/ret dcaFromAscii an/contentBytes
    elif eq s/inFormat 'asciiSafeSubset'
        set an/ret dcaFromAsciiSafeSubset an/contentBytes
    else
        error cat 'Unimplemented document parsing format: ' s/inFormat
    assertIsDcArray an/ret
    return an/ret

r/an/dcaToFormat s/outFormat an/dcArrayIn
    assertIsSupportedOutputFormat s/outFormat
    assertIsDcArray an/dcArrayIn
    new an/res
    if eq s/outFormat 'integerList'
        set an/res dcaToIntegerList an/dcArrayIn
    elif eq s/outFormat 'ascii'
        set an/res dcaToAscii an/dcArrayIn
    elif eq s/outFormat 'asciiSafeSubset'
        set an/res dcaToAsciiSafeSubset an/dcArrayIn
    elif eq s/outFormat 'html'
        set an/res dcaToHtml an/dcArrayIn
    else
        die cat 'Unimplemented document render output format: ' s/outFormat
    assertIsByteArray an/res
    return an/res

r/an/convertFormats s/inFormat s/outFormat an/in
    assertIsSupportedInputFormat s/inFormat
    assertIsSupportedOutputFormat s/outFormat
    assertIsByteArray an/in
    new an/out
    set an/out dcaToFormat s/outFormat dcaFromFormat s/inFormat an/in
    assertIsByteArray an/out
    return an/out

r/s/getExportExtension s/format
    # Produces the actual file extension to be used for a file exported in the given format, with the current configured format options.
    if eq s/format 'sems'
        return 'sems'
    elif eq s/format 'integerList'
        return 'dcil'
    elif eq s/format 'asciiSafeSubset'
        return 'ascii'
    elif eq s/format 'utf8'
        return 'utf8'
    elif eq s/format 'html'
        new s/res
        set s/res cat buildExportExtension getEnvCharEncoding } } '.htm'
        return s/res
    else
        die cat 'Format not supported: ' s/format

r/an/dcToFormat s/outFormat n/dc
    # Output byte array for a single dc, or an empty array if no output is available. Only operates on one Dc at a time. Some formats may not need this; calling with them is an error and should cause an assertion failure.
    assertIsSupportedOutputFormat s/outFormat
    assertIsDc n/dc
    new an/res
    if or eq s/outFormat 'utf8'
        set an/res push an/res utf8BytesFromDecimalChar hexToDec dcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
    elif eq s/outFormat 'html'
        set s/res dcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
        if isBaseStr s/res 16
            set an/res push an/res utf8BytesFromDecimalChar hexToDec s/res
        else
            set an/res push an/res strToByteArray dcDataLookupByValue 'mappings/to/html' 0 n/dc 1
    else
        error cat 'Unimplemented character output format: ' s/outFormat
    # Returns an empty array if the Dc isn't printable. I don't think it should be an error to call this for a nonprintable Dc.
    assertIsByteArray an/res
    return an/res

r/an/dcFromFormat s/inFormat an/content
    # Retrieve dc (as a one-element array) corresponding to the input data (input data for some formats may be expected as byte arrays, but not for others), or an empty array if no match. Only operates on one Dc at a time. Some formats (e.g. sems) don't need this; calling with them is an error and should cause an assertion failure.
    assertIsTrue isSupportedInternalFormat s/inFormat
    new an/ret
    new n/dc
    if or eq s/inFormat 'ascii' } eq s/inFormat 'unicode'
        new n/c
        set n/c get an/content 0
        if eq s/inFormat 'ascii'
            if not isAsciiByte n/c
                die cat 'The character number ' cat strFrom n/c } ' is not a 7-bit ASCII character.'
        assertIsNonnegative n/c
        if ge n/c dcDatasetLength 'mappings/from/unicode'
            die 'FIXME: save unmapped unicode chars'
            return an/ret
        set n/dc intFromIntStr dcDataLookupById 'mappings/from/unicode' n/c 1
    else
        die cat 'Unimplemented character source format: ' s/inFormat
    set an/ret setElement an/ret 0 n/dc
    assertIsDcArray an/ret
    return an/ret

r/v/exportWarning n/index s/problem
    warn cat 'An error was encountered while exporting at character ' cat strFrom n/index } cat ': ' s/problem

r/v/importWarning n/index s/problem
    warn cat 'An error was encountered while importing at character ' cat strFrom n/index } cat ': ' s/problem
