r/an/dcaFromFormat s/inFormat an/contentBytes
    assertIsSupportedInputFormat s/inFormat
    assertIsByteArray an/contentBytes
    new an/ret
    if eq s/inFormat 'sems'
        set an/ret dcaFromSems an/contentBytes
    elif eq s/inFormat 'integerList'
        set an/ret dcaFromIntegerList an/contentBytes
    elif eq s/inFormat 'ascii'
        set an/ret dcaFromAscii an/contentBytes
    elif eq s/inFormat 'asciiSafeSubset'
        set an/ret dcaFromAsciiSafeSubset an/contentBytes
    elif eq s/inFormat 'utf8'
        set an/ret dcaFromUtf8 an/contentBytes
    else
        error cat 'Unimplemented document parsing format: ' s/inFormat
    assertIsDcArray an/ret
    return an/ret

r/an/dcaToFormat s/outFormat an/dcArrayIn
    assertIsSupportedOutputFormat s/outFormat
    assertIsDcArray an/dcArrayIn
    new an/res
    if eq s/outFormat 'integerList'
        set an/res dcaToIntegerList an/dcArrayIn
    elif eq s/outFormat 'ascii'
        set an/res dcaToAscii an/dcArrayIn
    elif eq s/outFormat 'asciiSafeSubset'
        set an/res dcaToAsciiSafeSubset an/dcArrayIn
    #elif eq s/outFormat 'utf8'
    #    set an/ret dcaFromUtf8 an/contentBytes
    elif eq s/outFormat 'html'
        set an/res dcaToHtml an/dcArrayIn
    elif eq s/outFormat 'htmlFragment'
        set an/res dcaToHtmlFragment an/dcArrayIn
    else
        die cat 'Unimplemented document render output format: ' s/outFormat
    assertIsByteArray an/res
    return an/res

r/an/convertFormats s/inFormat s/outFormat an/in
    assertIsSupportedInputFormat s/inFormat
    assertIsSupportedOutputFormat s/outFormat
    assertIsByteArray an/in
    new an/out
    set an/out dcaToFormat s/outFormat dcaFromFormat s/inFormat an/in
    assertIsByteArray an/out
    return an/out

r/s/getExportExtension s/format
    # Produces the actual file extension to be used for a file exported in the given format, with the current configured format options.
    new s/res
    if isSupportedCharEncoding s/format
        set s/res cat getFormatExtension s/format } '.txt'
        return s/res
    set s/res getFormatExtension s/format
    return s/res

r/an/dcToFormat s/outFormat n/dc
    # Output byte array for a single dc, or an empty array if no output is available. Only operates on one Dc at a time. Some formats may not need this; calling with them is an error and should cause an assertion failure.
    assertIsSupportedOutputFormat s/outFormat
    assertIsDc n/dc
    new an/res
    if eq s/outFormat 'utf8'
        new s/lookup
        set s/lookup dcDataLookupById 'mappings/to/unicode' n/dc 1
        if excOrEmpty s/lookup
            set s/lookup dcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
        if notExcep s/lookup
            set an/res utf8BytesFromDecimalChar hexToDec s/lookup
    elif eq s/outFormat 'html'
        set s/res dcDataLookupById 'mappings/to/html' n/dc 1
        if strNonempty s/res
            set an/res strToByteArray s/res
        else
            set s/res dcDataLookupByValue 'mappings/from/unicode' 1 n/dc 0
            if isBaseStr s/res 16
                set an/res append an/res utf8BytesFromDecimalChar hexToDec s/res
    else
        error cat 'Unimplemented character output format: ' s/outFormat
    # Returns an empty array if the Dc isn't printable. I don't think it should be an error to call this for a nonprintable Dc.
    assertIsByteArray an/res
    return an/res

r/an/dcFromFormat s/inFormat an/content
    # Retrieve dc (as a one-element array) corresponding to the input data (input data for some formats may be expected as byte arrays, but not for others), or an empty array if no match. Only operates on one Dc at a time. Some formats (e.g. sems) don't need this; calling with them is an error and should cause an assertion failure.
    assertIsTrue isSupportedInternalFormat s/inFormat
    new an/ret
    new n/dc
    if or eq s/inFormat 'ascii' } eq s/inFormat 'unicode'
        new n/c
        set n/c get an/content 0
        if eq s/inFormat 'ascii'
            if not isAsciiByte n/c
                die cat 'The character number ' cat strFrom n/c } ' is not a 7-bit ASCII character.'
        assertIsNonnegative n/c
        if ge n/c dcDatasetLength 'mappings/from/unicode'
            die 'FIXME: save unmapped unicode chars'
            return an/ret
        set n/dc intFromIntStr dcDataLookupById 'mappings/from/unicode' n/c 1
    else
        die cat 'Unimplemented character source format: ' s/inFormat
    set an/ret setElement an/ret 0 n/dc
    assertIsDcArray an/ret
    return an/ret

r/v/exportWarning n/index s/problem
    warn cat 'An error was encountered while exporting at character ' cat strFrom n/index } cat ': ' s/problem

r/v/importWarning n/index s/problem
    warn cat 'An error was encountered while importing at character ' cat strFrom n/index } cat ': ' s/problem

r/v/exportWarningUnmappable n/index n/problemDc
    exportWarning n/index cat 'The character ' cat strFrom n/problemDc } ' could not be represented in the chosen export format.'
