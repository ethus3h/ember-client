dcaToUtf8() {
    IFS=$'\037' read -r -a intArrayContent <<< "$1"; shift; StageL_internalDebugCollect "intArray Content = $intArrayContent; "; StageL_internalDebugStackEnter 'dcaToUtf8:format-utf8'; StageL_assertIsIntArray "$(join_by $'\037' "${intArrayContent[@]}")"

    StageL_assertIsDcArray "$(join_by $'\037' "${intArrayContent[@]}")"
    intArrayRes=()
    intArrayToOutput=()
    intArrayToOutput="$(join_by $'\037' "${intArrayContent[@]}")"
    intArrayTemp=()
    intDcAtIndex='0'
    intArrayUnmappables=()
    intUnmappablesCount='0'
    intUnmappablesCounter='0'
    intArrayUnmappablesIntermediatePacked=()
    boolFoundAnyUnmappables='false'
    boolFoundAnyUnmappables='false'
    strArrayVariantSettings=()
    strArrayVariantSettings="$(StageL_utf8VariantSettings 'out')"
    boolDcBasenbEnabled='false'
    boolDcBasenbEnabled="$(StageL_contains "$(join_by $'\037' "${strArrayVariantSettings[@]}")" 'dcBasenb')"
    boolDcBasenbFragmentEnabled='false'
    boolDcBasenbFragmentEnabled="$(StageL_contains "$(join_by $'\037' "${strArrayVariantSettings[@]}")" 'dcBasenbFragment')"
    intArrayToOutput="$(StageL_dcPreprocessForFormat "$(join_by $'\037' "${intArrayToOutput[@]}")" 'utf8' 'out')"
    intL='0'
    intL="$(StageL_count "$(join_by $'\037' "${intArrayToOutput[@]}")")"
    intC='0'
    intC='0'
    while [[ "true" == "$(StageL_le "$intC" "$intL")" ]]; do
        # Start by getting the character's UTF8 equivalent and putting it in an/temp. This might be empty, if the character can't be mapped to UTF8.
        if [[ "true" == "$(StageL_lt "$intC" "$intL")" ]]; then
            intDcAtIndex="$(StageL_get "$(join_by $'\037' "${intArrayToOutput[@]}")" "$intC")"
            intArrayTemp="$(StageL_dcToFormat 'utf8' "$intDcAtIndex")"
        fi
        # Could the character be mapped? If not, stick it in the unmappables array or warn as appropriate.
        if [[ "true" == "$(StageL_eq '0' "$(StageL_count "$(join_by $'\037' "${intArrayTemp[@]}")")")" ]]; then
            if [[ "true" == "$(StageL_lt "$intC" "$intL")" ]]; then
                if [[ "true" == "$boolDcBasenbEnabled" ]]; then
                    intArrayUnmappables="$(StageL_push "$(join_by $'\037' "${intArrayUnmappables[@]}")" "$intDcAtIndex")"
                                else
                    StageL_exportWarningUnmappable "$intC" "$intDcAtIndex"
                fi
            fi
        fi
        # If we've reached the end of the input string or the last character was mappable, convert the an/unmappables array to PUA characters and append that result to the output string
        if [[ "true" == "$boolDcBasenbEnabled" ]]; then
            if [[ "true" == "$(StageL_or "$(StageL_eq "$intC" "$intL")" "$(StageL_ne '0' "$(StageL_count "$(join_by $'\037' "${intArrayTemp[@]}")")")")" ]]; then
                intUnmappablesCount="$(StageL_count "$(join_by $'\037' "${intArrayUnmappables[@]}")")"
                if [[ "true" == "$(StageL_ne '0' "$intUnmappablesCount")" ]]; then
                    if [[ "true" == "$(StageL_not "$boolFoundAnyUnmappables")" ]]; then
                        if [[ "true" == "$(StageL_not "$boolDcBasenbFragmentEnabled")" ]]; then
                            intArrayRes="$(StageL_append "$(join_by $'\037' "${intArrayRes[@]}")" "$(StageL_getArmoredUtf8EmbeddedStartUuid )")"
                        fi
                    fi
                    boolFoundAnyUnmappables='true'
                    # We've gotten to the end of a string of unmappable characters, so convert them to PUA characters
                    intUnmappablesCounter='0'
                    while [[ "true" == "$(StageL_lt "$intUnmappablesCounter" "$intUnmappablesCount")" ]]; do
                        # The packing method for this works basically like UTF8, where each character is mapped to a series of bytes. So, first get the bytearray for the character we're on. Each character should be packed separately, to make it easy to spot where one character ends and the next begins.
                        intArrayUnmappablesIntermediatePacked="$(StageL_append "$(join_by $'\037' "${intArrayUnmappablesIntermediatePacked[@]}")" "$(StageL_pack32 "$(StageL_get "$(join_by $'\037' "${intArrayUnmappables[@]}")" "$intUnmappablesCounter")")")"
                        intUnmappablesCounter="$(StageL_add "$intUnmappablesCounter" '1')"
                        intArrayRes="$(StageL_append "$(join_by $'\037' "${intArrayRes[@]}")" "$(StageL_byteArrayToBase17bUtf8 "$(join_by $'\037' "${intArrayUnmappablesIntermediatePacked[@]}")")")"
                        intArrayUnmappablesIntermediatePacked=(  )
                    done
                    intArrayUnmappables=(  )
                    intArrayUnmappablesIntermediatePacked=(  )
                fi
            fi
        fi
        # Stick the current character onto the result array
        if [[ "true" == "$(StageL_lt "$intC" "$intL")" ]]; then
            intArrayRes="$(StageL_append "$(join_by $'\037' "${intArrayRes[@]}")" "$(join_by $'\037' "${intArrayTemp[@]}")")"
        fi
        # and finally increment the loop counter
        intC="$(StageL_add "$intC" '1')"
    done
    if [[ "true" == "$(StageL_and "$boolDcBasenbEnabled" "$boolFoundAnyUnmappables")" ]]; then
        if [[ "true" == "$(StageL_not "$boolDcBasenbFragmentEnabled")" ]]; then
            intArrayRes="$(StageL_append "$(join_by $'\037' "${intArrayRes[@]}")" "$(StageL_getArmoredUtf8EmbeddedEndUuid )")"
        fi
    fi
    StageL_assertIsByteArray "$(join_by $'\037' "${intArrayRes[@]}")"

    intArrayReturn="$(join_by $'\037' "${intArrayRes[@]}")"; StageL_assertIsIntArray "$(join_by $'\037' "${intArrayReturn[@]}")"; StageL_internalDebugStackExit; print "$(join_by $'\037' "${intArrayReturn[@]}")"
}

dcaFromUtf8() {
    IFS=$'\037' read -r -a intArrayContent <<< "$1"; shift; StageL_internalDebugCollect "intArray Content = $intArrayContent; "; StageL_internalDebugStackEnter 'dcaFromUtf8:format-utf8'; StageL_assertIsIntArray "$(join_by $'\037' "${intArrayContent[@]}")"

    intArrayRes=()
    intArrayRemaining=()
    intArrayRemaining="$(join_by $'\037' "${intArrayContent[@]}")"
    intArrayTemp=()
    intArrayLatestChar=()
    intDcBasenbUuidMonitorState='0'
    intDcBasenbUuidMonitorState='0'
    intDcBasenbUuidMonitorReprocessNeededCount='0'
    intDcBasenbUuidMonitorReprocessNeededCount='0'
    strArrayVariantSettings=()
    strArrayVariantSettings="$(StageL_utf8VariantSettings 'in')"
    boolDcBasenbEnabled='false'
    boolDcBasenbEnabled="$(StageL_contains "$(join_by $'\037' "${strArrayVariantSettings[@]}")" 'dcBasenb')"
    boolInDcBasenbSection='false'
    boolInDcBasenbSection='false'
    if [[ "true" == "$boolDcBasenbEnabled" ]]; then
        boolInDcBasenbSection="$(StageL_contains "$(join_by $'\037' "${strArrayVariantSettings[@]}")" 'dcBasenbFragment')"
    fi
    intSkipThisChar='0'
    intSkipThisChar='0'
    intArrayCollectedDcBasenbChars=()
    intCollectedDcBasenbCharsCount='0'
    intCollectedDcBasenbCharsCounter='0'
    intArrayCurrentUnmappableChar=()
    intTempArrayCount='0'
    while [[ "true" == "$(StageL_not "$(StageL_eq '0' "$(StageL_count "$(join_by $'\037' "${intArrayRemaining[@]}")")")")" ]]; do
        intArrayTemp=(  )
        intArrayLatestChar="$(StageL_pack32 "$(StageL_firstCharOfUtf8String "$(join_by $'\037' "${intArrayRemaining[@]}")")")"
        if [[ "true" == "$boolDcBasenbEnabled" ]]; then
            # Dcbasenb is enabled, so process characters accordingly.
            if [[ "true" == "$(StageL_not "$boolInDcBasenbSection")" ]]; then
                # Not in a dcbasenb section, so look out for the UUID in case we run into one
                # All this code down to "(End of code section)" is only looking for UUIDs, and can mostly be disregarded for purposes of understanding the decoder logic.
                # 8 characters for uuid. Probably a better way to do this but oh well. Got them with new TextEncoder().encode('[char]'); etc.
                if [[ "true" == "$(StageL_ne '0' "$intDcBasenbUuidMonitorReprocessNeededCount")" ]]; then
                    # We're reprocessing potential UUID chars that didn't match a UUID after all, so don't check them for being a UUID. FIXME: Non-UUID char being reprocessed followed by 244 141 129 157 etc. (a potential UUID) would NOT be checked to be a UUID here. It should handle correctly the situation where there's potential but not a UUID, followed by potential and is a UUID, overlapping, like that.
                    intDcBasenbUuidMonitorReprocessNeededCount="$(StageL_sub "$intDcBasenbUuidMonitorReprocessNeededCount" '1')"
                                else
                    # Check for a UUID.
                    if [[ "true" == "$(StageL_eq "$intDcBasenbUuidMonitorState" '0')" ]]; then
                        if [[ "true" == "$(StageL_arrEq "$(join_by $'\037' "${intArrayLatestChar[@]}")" "$(join_by $'\037' '244' '141' '129' '157')")" ]]; then
                            intDcBasenbUuidMonitorState='1'
                        fi
                                        elif [[ "true" == "$(StageL_eq "$intDcBasenbUuidMonitorState" '1')" ]]; then
                        if [[ "true" == "$(StageL_arrEq "$(join_by $'\037' "${intArrayLatestChar[@]}")" "$(join_by $'\037' '244' '139' '182' '128')")" ]]; then
                            intDcBasenbUuidMonitorState='2'
                                                else
                            intDcBasenbUuidMonitorReprocessNeededCount="$intDcBasenbUuidMonitorState"
                            intDcBasenbUuidMonitorState='0'
                        fi
                                        elif [[ "true" == "$(StageL_eq "$intDcBasenbUuidMonitorState" '2')" ]]; then
                        if [[ "true" == "$(StageL_arrEq "$(join_by $'\037' "${intArrayLatestChar[@]}")" "$(join_by $'\037' '243' '188' '183' '162')")" ]]; then
                            intDcBasenbUuidMonitorState='3'
                                                else
                            intDcBasenbUuidMonitorReprocessNeededCount="$intDcBasenbUuidMonitorState"
                            intDcBasenbUuidMonitorState='0'
                        fi
                                        elif [[ "true" == "$(StageL_eq "$intDcBasenbUuidMonitorState" '3')" ]]; then
                        if [[ "true" == "$(StageL_arrEq "$(join_by $'\037' "${intArrayLatestChar[@]}")" "$(join_by $'\037' '243' '186' '128' '138')")" ]]; then
                            intDcBasenbUuidMonitorState='4'
                                                else
